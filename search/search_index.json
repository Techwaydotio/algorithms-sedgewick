{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solutions to Algorithms Forth Edition \u00b6 Getting Started \u00b6 This website contains nearly complete solutions to the textbook - Algorithms, 4th Edition , published by Robert Sedgewick and Kevin Wayne. I hope to organize solutions to help people and myself study algorithms. By using Markdown (.md) files, this page is much more readable on portable devices. How I Generate the Website? \u00b6 I use the static site generator MkDocs and the theme Material to build this website. We use KaTeX for rendering math expressions, which is fast and beautiful. License \u00b6 Licensed under the CC0 1.0 Universal (CC0 1.0) .","title":"Preface"},{"location":"#solutions-to-algorithms-forth-edition","text":"","title":"Solutions to Algorithms Forth Edition"},{"location":"#getting-started","text":"This website contains nearly complete solutions to the textbook - Algorithms, 4th Edition , published by Robert Sedgewick and Kevin Wayne. I hope to organize solutions to help people and myself study algorithms. By using Markdown (.md) files, this page is much more readable on portable devices.","title":"Getting Started"},{"location":"#how-i-generate-the-website","text":"I use the static site generator MkDocs and the theme Material to build this website. We use KaTeX for rendering math expressions, which is fast and beautiful.","title":"How I Generate the Website?"},{"location":"#license","text":"Licensed under the CC0 1.0 Universal (CC0 1.0) .","title":"License"},{"location":"Chap01/1.1/","text":"1.1.1 \u00b6 Give the value of each of the following expressions: a. ( 0 + 15 ) / 2 b. 2.0e-6 * 100000000.1 c. true && false || true && true a. jshell> (0 + 15) / 2 $1 ==> 7 b. jshell> 2.0e-6 * 100000000.1 $2 ==> 200.0000002 c. jshell> true && false || true && true $3 ==> true 1.1.2 \u00b6 Give the type and value of each of the following expressions: a. (1 + 2.236)/2 b. 1 + 2 + 3 + 4.0 c. 4.1 >= 4 d. 1 + 2 + \"3\" a. jshell> (1 + 2.236)/2 $1 ==> 1.618 jshell> ((Object)1.618).getClass().getName() $2 ==> \"java.lang.Double\" b. jshell> 1 + 2 + 3 + 4.0 $3 ==> 10.0 // Double c. jshell> 4.1 >= 4 $4 ==> true // Boolean d. jshell> 1 + 2 + \"3\" $5 ==> \"33\" 1.1.3 \u00b6 Write a program that takes three integer command-line arguments and prints equal if all three are equal, and not equal otherwise. public static void main ( String [] args ) { int first = Integer . parseInt ( args [ 0 ] ); int second = Integer . parseInt ( args [ 1 ] ); int third = Integer . parseInt ( args [ 2 ] ); if ( first == second && second == third ) { System . out . println ( \"equal\" ); } else { System . out . println ( \"not equal\" ); } } 1.1.4 \u00b6 What (if anything) is wrong with each of the following statements? a. if (a > b) then c = 0; b. if a > b { c = 0; } c. if (a > b) c = 0; d. if (a > b) c = 0 else b = 0; a. The programs does not compile. | Error: | variable declaration not allowed here | if (a > b) then c = 0; | ^---------^ b. The program fails to compile. | Error: | '(' expected | if a > b { c = 0; } | ^ | Error: | ')' expected | if a > b { c = 0; } | ^ c. The problem compiles. d. The problem does not compile. It's missing a semicolon; jshell> if (a > b) c = 0 else b = 0; | Error: | ';' expected | if (a > b) c = 0 else b = 0; | 1.1.5 \u00b6 Write a code fragment that prints true if the double variables x and y are both strictly between 0 and 1 and false otherwise. static boolean areBetween0and1 ( double x , double y ) { return isBetween0and1 ( x ) && isBetween0and1 ( y ); } static boolean isBetween0and1 ( double x ) { if ( x > 0 && x < 1 ) { return true ; } return false ; } 1.1.6 \u00b6 What does the following program print? int f = 0 ; int g = 1 ; for ( int i = 0 ; i <= 15 ; i ++ ) { StdOut . println ( f ); f = f + g ; g = f - g ; } It prints: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 1.1.7 \u00b6 Give the value printed by each of the following code fragments: a . double t = 9.0 ; while ( Math . abs ( t - 9.0 / t ) > .001 ) t = ( 9.0 / t + t ) / 2.0 ; StdOut . printf ( \"%.5f\\n\" , t ); b . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); c . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i *= 2 ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); a) 3.00009 b) 499500 c) 1023 1.1.8 \u00b6 What do each of the following print? a. System.out.println('b'); b. System.out.println('b' + 'c'); c. System.out.println((char) ('a' + 4)); Explain each outcome. a) It prints 'b' and a new line b) It prints 197. First 'b' is converted to int (98) and then 'c' to int (99) so the total is 98 + 99 = 197 c) It prints 'e'. First ('a' + 4) is converted to int. 'a' is 97 so result is 97 + 4 = 101. Then this int is converted to char which is 'e'; 1.1.11 \u00b6 Write a code fragment that prints the contents of a two-dimensional boolean array, using * to represent true and a space to represent false. Include row and column numbers. static void printContents ( boolean [][] arr ) { for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { if ( arr [ i ][ j ] ) { System . out . printf ( \"row: %d, column: %d = *\\n\" , i , j ); } else { System . out . printf ( \"row: %d, column: %d = \\n\" , i , j ); } } } } 1.1.12 \u00b6 What does the following code fragment print? int [] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = 9 - i ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = a [ a [ i ]] ; for ( int i = 0 ; i < 10 ; i ++ ) System . out . println ( i ); It prints: 0 1 2 3 4 5 6 7 8 9 1.1.13 \u00b6 Write a code fragment to print the transposition (rows and columns changed) of a two-dimensional array with M rows and N columns. static void printTranspose ( int [][] arr ) { int [][] result = new int [ arr [ 0 ] . length ][ arr . length ] ; for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { result [ j ][ i ] = arr [ i ][ j ] ; } } for ( int i = 0 ; i < result . length ; i += 1 ) { for ( int j = 0 ; j < result [ i ] . length ; j += 1 ) { System . out . printf ( \"row: %d, column: %d = %d\\n\" , i , j , result [ i ][ j ] ); } } } 1.1.14 \u00b6 Write a static method lg() that takes an int value N as argument and returns the largest int not larger than the base-2 logarithm of N. Do not use Math. static int lg ( int n ) { if ( n == 1 ) { return 0 ; } if ( n == 2 ) { return 1 ; } int acc = 2 ; int result = 1 ; while ( acc * 2 <= n ) { acc *= 2 ; result += 1 ; } return result ; } 1.1.15 \u00b6 Write a static method histogram() that takes an array a[] of int values and an integer M as arguments and returns an array of length M whose ith entry is the number of times the integer i appeared in the argument array. If the values in a[] are all between 0 and M\u20131, the sum of the values in the returned array should be equal to a.length. static int [] histogram ( int [] arr , int M ) { int [] result = new int [ M ] ; for ( int i : arr ) { if ( i < M ) { result [ i ] += 1 ; } } return result ; } 1.1.16 \u00b6 Give the value of exR1(6): public static String exR1 ( int n ) { if ( n <= 0 ) return \"\" ; return exR1 ( n - 3 ) + n + exR1 ( n - 2 ) + n ; } Result is 311361142246 1.1.18 \u00b6 Consider the following recursive function: public static int mystery ( int a , int b ) { if ( b == 0 ) return 0 ; if ( b % 2 == 0 ) return mystery ( a + a , b / 2 ); return mystery ( a + a , b / 2 ) + a ; } What are the values of mystery(2, 25) and mystery(3, 11)? Given positive integers a and b, describe what value mystery(a, b) computes. Answer the same question, but replace + with * and replace return 0 with return 1. mystery(2, 25) prints 2 * 25 = 50 mystery(3, 11) prints 3 * 11 = 33 mystery indeed computes $a * b$; If we replace + with * and 0 with 1 the fuction becomes: public static int mystery ( int a , int b ) { if ( b == 0 ) return 1 ; if ( b % 2 == 0 ) return mystery ( a * a , b / 2 ); return mystery ( a * a , b / 2 ) * a ; } This computes the value $a^b$. 1.1.19 \u00b6 Run the following program on your computer: public class Fibonacci { public static long F ( int N ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return 1 ; return F ( N - 1 ) + F ( N - 2 ); } public static void main ( String [] args ) { for ( int N = 0 ; N < 100 ; N ++ ) StdOut . println ( N + \" \" + F ( N )); } } What is the largest value of N for which this program takes less 1 hour to compute the value of F(N)? Develop a better implementation of F(N) that saves computed values in an array. On my machine any values more than 50 resulted in really slow computation. Here is a better version (using longs): public static long F ( long N ) { if ( N <= 1 ) { return N ; } long [] memo = new long [ ( int )( N + 1 ) ] ; memo [ 0 ] = 0 ; memo [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i += 1 ) { memo [ i ] = memo [ i - 1 ] + memo [ i - 2 ] ; } return memo [ ( int ) N ] ; } 1.1.20 \u00b6 Write a recursive static method that computes the value of ln (N !) Since $n! = 1 \u00d7 2 \u00d7 3 \u00d7 ... \u00d7 n$, then $ log(n!) = log(1) + log(2) + log(3) + \u2026 + log(n)$. Computing this for large values of n is costly. Since we are not asked for an approximation we can just calculate it directly. (using the lg function we implemented earlier) static int lnProduct ( int n ) { if ( n == 1 ) { return 0 ; } return lg ( n ) + lnProduct ( n - 1 ); } 1.1.21 \u00b6 Write a program that reads in lines from standard input with each line containing a name and two integers and then uses printf() to print a table with a column of the names, the integers, and the result of dividing the first by the second, accurate to three decimal places. You could use a program like this to tabulate batting averages for baseball players or grades for students. public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); while ( input . hasNextLine ()) { String line = input . nextLine (); String [] words = line . split ( \" \" ); String name = words [ 0 ] ; double first = Double . parseDouble ( words [ 1 ] ); double second = Double . parseDouble ( words [ 2 ] ); System . out . printf ( \"Name: %s, Div: %.3f\\n\" , name , first / second ); } } 1.1.22 \u00b6 Write a version of BinarySearch that uses the recursive rank() given on page 25 and traces the method calls. Each time the recursive method is called, print the argument values lo and hi, indented by the depth of the recursion. Hint: Add an argument to the recursive method that keeps track of the depth. public static int rank ( int key , int [] a ) { return rank ( key , a , 0 , a . length - 1 , 0 ); } public static String padLeft ( String inputString , int length ) { StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < length ; i ++ ) { sb . append ( ' ' ); } return sb . toString () + inputString ; } public static int rank ( int key , int [] a , int lo , int hi , int depth ) { String out = padLeft ( String . format ( \"lo: %d, hi: %d\\n\" , lo , hi ), depth ); System . out . print ( out ); if ( lo > hi ) return - 1 ; int mid = lo + ( hi - lo ) / 2 ; if ( key < a [ mid ] ) return rank ( key , a , lo , mid - 1 , depth + 1 ); else if ( key > a [ mid ] ) return rank ( key , a , mid + 1 , hi , depth + 1 ); else return mid ; }","title":"1.1   Programming Model"},{"location":"Chap01/1.1/#111","text":"Give the value of each of the following expressions: a. ( 0 + 15 ) / 2 b. 2.0e-6 * 100000000.1 c. true && false || true && true a. jshell> (0 + 15) / 2 $1 ==> 7 b. jshell> 2.0e-6 * 100000000.1 $2 ==> 200.0000002 c. jshell> true && false || true && true $3 ==> true","title":"1.1.1"},{"location":"Chap01/1.1/#112","text":"Give the type and value of each of the following expressions: a. (1 + 2.236)/2 b. 1 + 2 + 3 + 4.0 c. 4.1 >= 4 d. 1 + 2 + \"3\" a. jshell> (1 + 2.236)/2 $1 ==> 1.618 jshell> ((Object)1.618).getClass().getName() $2 ==> \"java.lang.Double\" b. jshell> 1 + 2 + 3 + 4.0 $3 ==> 10.0 // Double c. jshell> 4.1 >= 4 $4 ==> true // Boolean d. jshell> 1 + 2 + \"3\" $5 ==> \"33\"","title":"1.1.2"},{"location":"Chap01/1.1/#113","text":"Write a program that takes three integer command-line arguments and prints equal if all three are equal, and not equal otherwise. public static void main ( String [] args ) { int first = Integer . parseInt ( args [ 0 ] ); int second = Integer . parseInt ( args [ 1 ] ); int third = Integer . parseInt ( args [ 2 ] ); if ( first == second && second == third ) { System . out . println ( \"equal\" ); } else { System . out . println ( \"not equal\" ); } }","title":"1.1.3"},{"location":"Chap01/1.1/#114","text":"What (if anything) is wrong with each of the following statements? a. if (a > b) then c = 0; b. if a > b { c = 0; } c. if (a > b) c = 0; d. if (a > b) c = 0 else b = 0; a. The programs does not compile. | Error: | variable declaration not allowed here | if (a > b) then c = 0; | ^---------^ b. The program fails to compile. | Error: | '(' expected | if a > b { c = 0; } | ^ | Error: | ')' expected | if a > b { c = 0; } | ^ c. The problem compiles. d. The problem does not compile. It's missing a semicolon; jshell> if (a > b) c = 0 else b = 0; | Error: | ';' expected | if (a > b) c = 0 else b = 0; |","title":"1.1.4"},{"location":"Chap01/1.1/#115","text":"Write a code fragment that prints true if the double variables x and y are both strictly between 0 and 1 and false otherwise. static boolean areBetween0and1 ( double x , double y ) { return isBetween0and1 ( x ) && isBetween0and1 ( y ); } static boolean isBetween0and1 ( double x ) { if ( x > 0 && x < 1 ) { return true ; } return false ; }","title":"1.1.5"},{"location":"Chap01/1.1/#116","text":"What does the following program print? int f = 0 ; int g = 1 ; for ( int i = 0 ; i <= 15 ; i ++ ) { StdOut . println ( f ); f = f + g ; g = f - g ; } It prints: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610","title":"1.1.6"},{"location":"Chap01/1.1/#117","text":"Give the value printed by each of the following code fragments: a . double t = 9.0 ; while ( Math . abs ( t - 9.0 / t ) > .001 ) t = ( 9.0 / t + t ) / 2.0 ; StdOut . printf ( \"%.5f\\n\" , t ); b . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); c . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i *= 2 ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); a) 3.00009 b) 499500 c) 1023","title":"1.1.7"},{"location":"Chap01/1.1/#118","text":"What do each of the following print? a. System.out.println('b'); b. System.out.println('b' + 'c'); c. System.out.println((char) ('a' + 4)); Explain each outcome. a) It prints 'b' and a new line b) It prints 197. First 'b' is converted to int (98) and then 'c' to int (99) so the total is 98 + 99 = 197 c) It prints 'e'. First ('a' + 4) is converted to int. 'a' is 97 so result is 97 + 4 = 101. Then this int is converted to char which is 'e';","title":"1.1.8"},{"location":"Chap01/1.1/#1111","text":"Write a code fragment that prints the contents of a two-dimensional boolean array, using * to represent true and a space to represent false. Include row and column numbers. static void printContents ( boolean [][] arr ) { for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { if ( arr [ i ][ j ] ) { System . out . printf ( \"row: %d, column: %d = *\\n\" , i , j ); } else { System . out . printf ( \"row: %d, column: %d = \\n\" , i , j ); } } } }","title":"1.1.11"},{"location":"Chap01/1.1/#1112","text":"What does the following code fragment print? int [] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = 9 - i ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = a [ a [ i ]] ; for ( int i = 0 ; i < 10 ; i ++ ) System . out . println ( i ); It prints: 0 1 2 3 4 5 6 7 8 9","title":"1.1.12"},{"location":"Chap01/1.1/#1113","text":"Write a code fragment to print the transposition (rows and columns changed) of a two-dimensional array with M rows and N columns. static void printTranspose ( int [][] arr ) { int [][] result = new int [ arr [ 0 ] . length ][ arr . length ] ; for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { result [ j ][ i ] = arr [ i ][ j ] ; } } for ( int i = 0 ; i < result . length ; i += 1 ) { for ( int j = 0 ; j < result [ i ] . length ; j += 1 ) { System . out . printf ( \"row: %d, column: %d = %d\\n\" , i , j , result [ i ][ j ] ); } } }","title":"1.1.13"},{"location":"Chap01/1.1/#1114","text":"Write a static method lg() that takes an int value N as argument and returns the largest int not larger than the base-2 logarithm of N. Do not use Math. static int lg ( int n ) { if ( n == 1 ) { return 0 ; } if ( n == 2 ) { return 1 ; } int acc = 2 ; int result = 1 ; while ( acc * 2 <= n ) { acc *= 2 ; result += 1 ; } return result ; }","title":"1.1.14"},{"location":"Chap01/1.1/#1115","text":"Write a static method histogram() that takes an array a[] of int values and an integer M as arguments and returns an array of length M whose ith entry is the number of times the integer i appeared in the argument array. If the values in a[] are all between 0 and M\u20131, the sum of the values in the returned array should be equal to a.length. static int [] histogram ( int [] arr , int M ) { int [] result = new int [ M ] ; for ( int i : arr ) { if ( i < M ) { result [ i ] += 1 ; } } return result ; }","title":"1.1.15"},{"location":"Chap01/1.1/#1116","text":"Give the value of exR1(6): public static String exR1 ( int n ) { if ( n <= 0 ) return \"\" ; return exR1 ( n - 3 ) + n + exR1 ( n - 2 ) + n ; } Result is 311361142246","title":"1.1.16"},{"location":"Chap01/1.1/#1118","text":"Consider the following recursive function: public static int mystery ( int a , int b ) { if ( b == 0 ) return 0 ; if ( b % 2 == 0 ) return mystery ( a + a , b / 2 ); return mystery ( a + a , b / 2 ) + a ; } What are the values of mystery(2, 25) and mystery(3, 11)? Given positive integers a and b, describe what value mystery(a, b) computes. Answer the same question, but replace + with * and replace return 0 with return 1. mystery(2, 25) prints 2 * 25 = 50 mystery(3, 11) prints 3 * 11 = 33 mystery indeed computes $a * b$; If we replace + with * and 0 with 1 the fuction becomes: public static int mystery ( int a , int b ) { if ( b == 0 ) return 1 ; if ( b % 2 == 0 ) return mystery ( a * a , b / 2 ); return mystery ( a * a , b / 2 ) * a ; } This computes the value $a^b$.","title":"1.1.18"},{"location":"Chap01/1.1/#1119","text":"Run the following program on your computer: public class Fibonacci { public static long F ( int N ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return 1 ; return F ( N - 1 ) + F ( N - 2 ); } public static void main ( String [] args ) { for ( int N = 0 ; N < 100 ; N ++ ) StdOut . println ( N + \" \" + F ( N )); } } What is the largest value of N for which this program takes less 1 hour to compute the value of F(N)? Develop a better implementation of F(N) that saves computed values in an array. On my machine any values more than 50 resulted in really slow computation. Here is a better version (using longs): public static long F ( long N ) { if ( N <= 1 ) { return N ; } long [] memo = new long [ ( int )( N + 1 ) ] ; memo [ 0 ] = 0 ; memo [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i += 1 ) { memo [ i ] = memo [ i - 1 ] + memo [ i - 2 ] ; } return memo [ ( int ) N ] ; }","title":"1.1.19"},{"location":"Chap01/1.1/#1120","text":"Write a recursive static method that computes the value of ln (N !) Since $n! = 1 \u00d7 2 \u00d7 3 \u00d7 ... \u00d7 n$, then $ log(n!) = log(1) + log(2) + log(3) + \u2026 + log(n)$. Computing this for large values of n is costly. Since we are not asked for an approximation we can just calculate it directly. (using the lg function we implemented earlier) static int lnProduct ( int n ) { if ( n == 1 ) { return 0 ; } return lg ( n ) + lnProduct ( n - 1 ); }","title":"1.1.20"},{"location":"Chap01/1.1/#1121","text":"Write a program that reads in lines from standard input with each line containing a name and two integers and then uses printf() to print a table with a column of the names, the integers, and the result of dividing the first by the second, accurate to three decimal places. You could use a program like this to tabulate batting averages for baseball players or grades for students. public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); while ( input . hasNextLine ()) { String line = input . nextLine (); String [] words = line . split ( \" \" ); String name = words [ 0 ] ; double first = Double . parseDouble ( words [ 1 ] ); double second = Double . parseDouble ( words [ 2 ] ); System . out . printf ( \"Name: %s, Div: %.3f\\n\" , name , first / second ); } }","title":"1.1.21"},{"location":"Chap01/1.1/#1122","text":"Write a version of BinarySearch that uses the recursive rank() given on page 25 and traces the method calls. Each time the recursive method is called, print the argument values lo and hi, indented by the depth of the recursion. Hint: Add an argument to the recursive method that keeps track of the depth. public static int rank ( int key , int [] a ) { return rank ( key , a , 0 , a . length - 1 , 0 ); } public static String padLeft ( String inputString , int length ) { StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < length ; i ++ ) { sb . append ( ' ' ); } return sb . toString () + inputString ; } public static int rank ( int key , int [] a , int lo , int hi , int depth ) { String out = padLeft ( String . format ( \"lo: %d, hi: %d\\n\" , lo , hi ), depth ); System . out . print ( out ); if ( lo > hi ) return - 1 ; int mid = lo + ( hi - lo ) / 2 ; if ( key < a [ mid ] ) return rank ( key , a , lo , mid - 1 , depth + 1 ); else if ( key > a [ mid ] ) return rank ( key , a , mid + 1 , hi , depth + 1 ); else return mid ; }","title":"1.1.22"},{"location":"Chap01/1.2/","text":"","title":"1.2   Data Abstraction"},{"location":"Chap01/1.3/","text":"","title":"1.3   Bags, Queues, and Stacks"},{"location":"Chap01/1.4/","text":"","title":"1.4   Analysis of Algorithms"},{"location":"Chap01/1.5/","text":"","title":"1.5   Case Study - Union-Find"}]}