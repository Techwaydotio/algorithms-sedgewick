{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solutions to Algorithms Forth Edition \u00b6 Getting Started \u00b6 This website contains nearly complete solutions to the textbook - Algorithms, 4th Edition , published by Robert Sedgewick and Kevin Wayne. I hope to organize solutions to help people and myself study algorithms. By using Markdown (.md) files, this page is much more readable on portable devices. How I Generate the Website? \u00b6 I use the static site generator MkDocs and the theme Material to build this website. We use KaTeX for rendering math expressions, which is fast and beautiful. License \u00b6 Licensed under the CC0 1.0 Universal (CC0 1.0) .","title":"Preface"},{"location":"#solutions-to-algorithms-forth-edition","text":"","title":"Solutions to Algorithms Forth Edition"},{"location":"#getting-started","text":"This website contains nearly complete solutions to the textbook - Algorithms, 4th Edition , published by Robert Sedgewick and Kevin Wayne. I hope to organize solutions to help people and myself study algorithms. By using Markdown (.md) files, this page is much more readable on portable devices.","title":"Getting Started"},{"location":"#how-i-generate-the-website","text":"I use the static site generator MkDocs and the theme Material to build this website. We use KaTeX for rendering math expressions, which is fast and beautiful.","title":"How I Generate the Website?"},{"location":"#license","text":"Licensed under the CC0 1.0 Universal (CC0 1.0) .","title":"License"},{"location":"Chap01/1.1/","text":"1.1.1 \u00b6 Give the value of each of the following expressions: a. ( 0 + 15 ) / 2 b. 2.0e-6 * 100000000.1 c. true && false || true && true a. jshell> (0 + 15) / 2 $1 ==> 7 b. jshell> 2.0e-6 * 100000000.1 $2 ==> 200.0000002 c. jshell> true && false || true && true $3 ==> true 1.1.2 \u00b6 Give the type and value of each of the following expressions: a. (1 + 2.236)/2 b. 1 + 2 + 3 + 4.0 c. 4.1 >= 4 d. 1 + 2 + \"3\" a. jshell> (1 + 2.236)/2 $1 ==> 1.618 jshell> ((Object)1.618).getClass().getName() $2 ==> \"java.lang.Double\" b. jshell> 1 + 2 + 3 + 4.0 $3 ==> 10.0 // Double c. jshell> 4.1 >= 4 $4 ==> true // Boolean d. jshell> 1 + 2 + \"3\" $5 ==> \"33\" 1.1.3 \u00b6 Write a program that takes three integer command-line arguments and prints equal if all three are equal, and not equal otherwise. public static void main ( String [] args ) { int first = Integer . parseInt ( args [ 0 ] ); int second = Integer . parseInt ( args [ 1 ] ); int third = Integer . parseInt ( args [ 2 ] ); if ( first == second && second == third ) { System . out . println ( \"equal\" ); } else { System . out . println ( \"not equal\" ); } } 1.1.4 \u00b6 What (if anything) is wrong with each of the following statements? a. if (a > b) then c = 0; b. if a > b { c = 0; } c. if (a > b) c = 0; d. if (a > b) c = 0 else b = 0; a. The programs does not compile. | Error: | variable declaration not allowed here | if (a > b) then c = 0; | ^---------^ b. The program fails to compile. | Error: | '(' expected | if a > b { c = 0; } | ^ | Error: | ')' expected | if a > b { c = 0; } | ^ c. The problem compiles. d. The problem does not compile. It's missing a semicolon; jshell> if (a > b) c = 0 else b = 0; | Error: | ';' expected | if (a > b) c = 0 else b = 0; | 1.1.5 \u00b6 Write a code fragment that prints true if the double variables x and y are both strictly between 0 and 1 and false otherwise. static boolean areBetween0and1 ( double x , double y ) { return isBetween0and1 ( x ) && isBetween0and1 ( y ); } static boolean isBetween0and1 ( double x ) { if ( x > 0 && x < 1 ) { return true ; } return false ; } 1.1.6 \u00b6 What does the following program print? int f = 0 ; int g = 1 ; for ( int i = 0 ; i <= 15 ; i ++ ) { StdOut . println ( f ); f = f + g ; g = f - g ; } It prints: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 1.1.7 \u00b6 Give the value printed by each of the following code fragments: a . double t = 9.0 ; while ( Math . abs ( t - 9.0 / t ) > .001 ) t = ( 9.0 / t + t ) / 2.0 ; StdOut . printf ( \"%.5f\\n\" , t ); b . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); c . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i *= 2 ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); a) 3.00009 b) 499500 c) 1023 1.1.8 \u00b6 What do each of the following print? a. System.out.println('b'); b. System.out.println('b' + 'c'); c. System.out.println((char) ('a' + 4)); Explain each outcome. a) It prints 'b' and a new line b) It prints 197. First 'b' is converted to int (98) and then 'c' to int (99) so the total is 98 + 99 = 197 c) It prints 'e'. First ('a' + 4) is converted to int. 'a' is 97 so result is 97 + 4 = 101. Then this int is converted to char which is 'e'; 1.1.11 \u00b6 Write a code fragment that prints the contents of a two-dimensional boolean array, using * to represent true and a space to represent false. Include row and column numbers. static void printContents ( boolean [][] arr ) { for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { if ( arr [ i ][ j ] ) { System . out . printf ( \"row: %d, column: %d = *\\n\" , i , j ); } else { System . out . printf ( \"row: %d, column: %d = \\n\" , i , j ); } } } } 1.1.12 \u00b6 What does the following code fragment print? int [] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = 9 - i ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = a [ a [ i ]] ; for ( int i = 0 ; i < 10 ; i ++ ) System . out . println ( i ); It prints: 0 1 2 3 4 5 6 7 8 9 1.1.13 \u00b6 Write a code fragment to print the transposition (rows and columns changed) of a two-dimensional array with M rows and N columns. static void printTranspose ( int [][] arr ) { int [][] result = new int [ arr [ 0 ] . length ][ arr . length ] ; for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { result [ j ][ i ] = arr [ i ][ j ] ; } } for ( int i = 0 ; i < result . length ; i += 1 ) { for ( int j = 0 ; j < result [ i ] . length ; j += 1 ) { System . out . printf ( \"row: %d, column: %d = %d\\n\" , i , j , result [ i ][ j ] ); } } } 1.1.14 \u00b6 Write a static method lg() that takes an int value N as argument and returns the largest int not larger than the base-2 logarithm of N. Do not use Math. static int lg ( int n ) { if ( n == 1 ) { return 0 ; } if ( n == 2 ) { return 1 ; } int acc = 2 ; int result = 1 ; while ( acc * 2 <= n ) { acc *= 2 ; result += 1 ; } return result ; } 1.1.15 \u00b6 Write a static method histogram() that takes an array a[] of int values and an integer M as arguments and returns an array of length M whose ith entry is the number of times the integer i appeared in the argument array. If the values in a[] are all between 0 and M\u20131, the sum of the values in the returned array should be equal to a.length. static int [] histogram ( int [] arr , int M ) { int [] result = new int [ M ] ; for ( int i : arr ) { if ( i < M ) { result [ i ] += 1 ; } } return result ; } 1.1.16 \u00b6 Give the value of exR1(6): public static String exR1 ( int n ) { if ( n <= 0 ) return \"\" ; return exR1 ( n - 3 ) + n + exR1 ( n - 2 ) + n ; } Result is 311361142246 1.1.18 \u00b6 Consider the following recursive function: public static int mystery ( int a , int b ) { if ( b == 0 ) return 0 ; if ( b % 2 == 0 ) return mystery ( a + a , b / 2 ); return mystery ( a + a , b / 2 ) + a ; } What are the values of mystery(2, 25) and mystery(3, 11)? Given positive integers a and b, describe what value mystery(a, b) computes. Answer the same question, but replace + with * and replace return 0 with return 1. mystery(2, 25) prints 2 * 25 = 50 mystery(3, 11) prints 3 * 11 = 33 mystery indeed computes $a * b$; If we replace + with * and 0 with 1 the fuction becomes: public static int mystery ( int a , int b ) { if ( b == 0 ) return 1 ; if ( b % 2 == 0 ) return mystery ( a * a , b / 2 ); return mystery ( a * a , b / 2 ) * a ; } This computes the value $a^b$. 1.1.19 \u00b6 Run the following program on your computer: public class Fibonacci { public static long F ( int N ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return 1 ; return F ( N - 1 ) + F ( N - 2 ); } public static void main ( String [] args ) { for ( int N = 0 ; N < 100 ; N ++ ) StdOut . println ( N + \" \" + F ( N )); } } What is the largest value of N for which this program takes less 1 hour to compute the value of F(N)? Develop a better implementation of F(N) that saves computed values in an array. On my machine any values more than 50 resulted in really slow computation. Here is a better version (using longs): public static long F ( long N ) { if ( N <= 1 ) { return N ; } long [] memo = new long [ ( int )( N + 1 ) ] ; memo [ 0 ] = 0 ; memo [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i += 1 ) { memo [ i ] = memo [ i - 1 ] + memo [ i - 2 ] ; } return memo [ ( int ) N ] ; } 1.1.20 \u00b6 Write a recursive static method that computes the value of ln (N !) Since $n! = 1 \u00d7 2 \u00d7 3 \u00d7 ... \u00d7 n$, then $ log(n!) = log(1) + log(2) + log(3) + \u2026 + log(n)$. Computing this for large values of n is costly. Since we are not asked for an approximation we can just calculate it directly. (using the lg function we implemented earlier) static int lnProduct ( int n ) { if ( n == 1 ) { return 0 ; } return lg ( n ) + lnProduct ( n - 1 ); } 1.1.21 \u00b6 Write a program that reads in lines from standard input with each line containing a name and two integers and then uses printf() to print a table with a column of the names, the integers, and the result of dividing the first by the second, accurate to three decimal places. You could use a program like this to tabulate batting averages for baseball players or grades for students. public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); while ( input . hasNextLine ()) { String line = input . nextLine (); String [] words = line . split ( \" \" ); String name = words [ 0 ] ; double first = Double . parseDouble ( words [ 1 ] ); double second = Double . parseDouble ( words [ 2 ] ); System . out . printf ( \"Name: %s, Div: %.3f\\n\" , name , first / second ); } } 1.1.22 \u00b6 Write a version of BinarySearch that uses the recursive rank() given on page 25 and traces the method calls. Each time the recursive method is called, print the argument values lo and hi, indented by the depth of the recursion. Hint: Add an argument to the recursive method that keeps track of the depth. public static int rank ( int key , int [] a ) { return rank ( key , a , 0 , a . length - 1 , 0 ); } public static String padLeft ( String inputString , int length ) { StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < length ; i ++ ) { sb . append ( ' ' ); } return sb . toString () + inputString ; } public static int rank ( int key , int [] a , int lo , int hi , int depth ) { String out = padLeft ( String . format ( \"lo: %d, hi: %d\\n\" , lo , hi ), depth ); System . out . print ( out ); if ( lo > hi ) return - 1 ; int mid = lo + ( hi - lo ) / 2 ; if ( key < a [ mid ] ) return rank ( key , a , lo , mid - 1 , depth + 1 ); else if ( key > a [ mid ] ) return rank ( key , a , mid + 1 , hi , depth + 1 ); else return mid ; } 1.1.23 Add to the BinarySearch test client the ability to respond to a second argument: + to print numbers from standard input that are not in the whitelist, - to print numbers that are in the whitelist. public static void main ( String [] args ) { int [] whitelist = readInts ( args [ 0 ] ); boolean printNotFromWhitelist = true ; if ( args [ 1 ] . equals ( \"+\" )) { printNotFromWhitelist = true ; } if ( args [ 1 ] . equals ( \"-\" )) { printNotFromWhitelist = false ; } Scanner scanner = new Scanner ( System . in ); Arrays . sort ( whitelist ); while ( scanner . hasNext ()) { // Read key, print if not in whitelist. int key = scanner . nextInt (); boolean notFound = rank ( key , whitelist ) < 0 ; // Print numbers from standard input that are not in the whitelist if ( notFound && printNotFromWhitelist ) { System . out . println ( key ); } // Print numbers from standard input that are in the whitelist if ( ! notFound && ! printNotFromWhitelist ) { System . out . println ( key ); } } } 1.1.24 \u00b6 Give the sequence of values of p and q that are computed when Euclid\u2019s algorithm is used to compute the greatest common divisor of 105 and 24. Extend the code given on page 4 to develop a program Euclid that takes two integers from the command line and computes their greatest common divisor, printing out the two arguments for each call on the recursive method. Use your program to compute the greatest common divisor or 1111111 and 1234567. Solution trivial... 1.1.25 \u00b6 Use mathematical induction to prove that Euclid\u2019s algorithm computes the greatest common divisor of any pair of nonnegative integers p and q. In GCD the process terminates when a remainder of 0 is reached, and the last nonzero remainder in the process is gcd(p, q) with $p \u2265 q$ The process in the Euclidean algorithm produces a strictly decreasing sequence of remainders $r0 > r1 > r2 > \u00b7 \u00b7 \u00b7 >rn+1 = 0$ Hence the algorithm stops after no more than q divisions. If $rn$ is the last non-zero remainder in the process, then we have $rn = gcd(rn, 0) = gcd(rn\u22121, rn) = ... = gcd(r0, r1) = gcd(p, q).$ For the base step $i = 0$, we have $gcd(p, q) = gcd(r0, r1)$ by definition of $r0 = a$ and $r1 = b$. For each i in 0 \u2264 i < n we have $gcd(ri, ri+1) = gcd(ri+1, ri+2)$ This shows that if $gcd(a, b) = gcd(ri, ri+1)$, then $gcd(a, b) = gcd(ri+1, ri+2),$ which is the induction step. 1.1.26 \u00b6 Sorting three numbers. Suppose that the variables a, b, c, and t are all of the same numeric primitive type. Show that the following code puts a, b, and c in ascending order: if ( a > b ) { t = a ; a = b ; b = t ; } if ( a > c ) { t = a ; a = c ; c = t ; } if ( b > c ) { t = b ; b = c ; c = t ; } The first if checks if $a > b$ and swaps $a$ with $b$. At the end we have $a < b$; The second if checks if $a > c$ and swaps $a$ with $c$. At the end we have $a < c$; The last if checks if $b > c$ and swaps $b$ with $c$. At the end we have $b < c$; From all three we have $a < b < c$. For example if $a=3, b=2, c=1$ we have: $3 > 2$ then $a = 2, b = 3$ $2 > 1$ then $a = 1, c = 2$ $3 > 2$ then $c = 3, b = 2$ 1.1.27 \u00b6 Binomial distribution. Estimate the number of recursive calls that would be used by the code: public static double binomial ( int N , int k , double p ) { if (( N == 0 ) || ( k < 0 )) return 1.0 ; return ( 1.0 - p ) * binomial ( N - 1 , k ) + p * binomial ( N - 1 , k - 1 ); } to compute binomial(100, 50). Develop a better implementation that is based on saving computed values in an array. Code seems to be wrong! We don't have a definition of binomial with two parameters! The code should have been: static int nChoseR ( int n , int r ) { // Since nCr is same as nC(n-r) // To decrease number of iterations if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ); answer /= i ; } return answer ; } static float binomialProbability ( int n , int k , float p ) { return nChoseR ( n , k ) * ( float ) Math . pow ( p , k ) * ( float ) Math . pow ( 1 - p , n - k ); } 1.1.28 \u00b6 Remove duplicates. Modify the test client in BinarySearch to remove any duplicate keys in the whitelist after the sort. When you find one of the indexes you're looking for, and from there, then check all the left and right indexes for the same value and remove them from the array public static void main ( String [] args ) { int [] whitelist = In . readInts ( args [ 0 ] ); Arrays . sort ( whitelist ); while ( ! StdIn . isEmpty ()) { // Read key, print if not in whitelist. int key = StdIn . readInt (); int index = rank ( key , whitelist ); // finds index of duplicate if ( index >= 0 ) { int start = index - 1 , end = index + 1 ; // Check left of index while ( start != 0 && whitelist [ start ] == key ) { if ( whitelist [ start ] == key ) { start -= 1 ; } else { break ; } } // Check right of index while ( end != whitelist . length - 1 ) { if ( whitelist [ end ] == key ) { end += 1 ; } else { break ; } } int numOfDuplicates = end - start ; if ( numOfDuplicates > 0 ) { // Copy first part int [] first = Arrays . copyOfRange ( whitelist , 0 , start ); // Copy second part int [] second = Arrays . copyOfRange ( whitelist , end + 1 , whitelist . length - 1 ); // Create result array with no duplicate keys int [] result = new int [ first . length + second . length + 1 ] ; System . arraycopy ( first , 0 , result , 0 , first . length ); // Assign key in position result [ first . length ] = key ; // Combine the results System . arraycopy ( second , 0 , result , first . length + 1 , second . length ); whitelist = result ; } } } } 1.1.29 \u00b6 Equal keys. Add to BinarySearch a static method rank() that takes a key and a sorted array of int values (some of which may be equal) as arguments and returns the number of elements that are smaller than the key and a similar method count() that returns the number of elements equal to the key. Note : If i and j are the values returned by rank(key, a) and count(key, a) respectively, then a[i..i+j-1] are the values in the array that are equal to key. /* Returns the number of elements that are smaller than the key */ static int rank ( int key , int [] a ) { int index = Arrays . binarySearch ( a , key ); int lessThanCount = 0 ; if ( index >= 0 ) { int curr = index - 1 ; while ( curr >= 0 ) { if ( a [ curr ] != key ) { lessThanCount += 1 ; } curr -= 1 ; } } return lessThanCount ; } /* Returns the number of elements equal to the key */ static int count ( int key , int [] a ) { int index = Arrays . binarySearch ( a , key ); int count = 0 ; if ( index >= 0 ) { count += 1 ; int start = index - 1 , end = index + 1 ; // Check left of index while ( start >= 0 ) { if ( a [ start ] == key ) { start -= 1 ; count += 1 ; } else { break ; } } // Check right of index while ( end < a . length - 1 ) { if ( a [ end ] == key ) { end += 1 ; count += 1 ; } else { break ; } } } return count ; } 1.1.30 \u00b6 Array exercise. Write a code fragment that creates an N-by-N boolean array a[][] such that a[i][j] is true if i and j are relatively prime (have no common factors), and false otherwise. If the greatest common divisor (gcd) of 2 numbers a and b is 1 (i.e. gcd(a, b) = 1) then a and b are relatively prime. static boolean [][] relPrimeTable ( int N ) { boolean [][] result = new boolean [ N ][ N ] ; for ( int i = 0 ; i < N ; i += 1 ) { for ( int j = 0 ; j < N ; j += 1 ) { result [ i ][ j ] = gcd ( i , j ) == 1 ; } } return result ; } 1.1.31 \u00b6 Random connections. Write a program that takes as command-line arguments an integer N and a double value p (between 0 and 1), plots N equally spaced dots of size .05 on the circumference of a circle, and then, with probability p for each pair of points, draws a gray line connecting them. public class Ex1131 extends Canvas { int N ; double p ; Ex1131 ( int N , double p ) { this . N = N ; this . p = p ; } public static void main ( String [] args ) { int N = Integer . parseInt ( args [ 0 ] ); double p = Double . parseDouble ( args [ 1 ] ); JFrame frame = new JFrame ( \"Random Connections\" ); Canvas canvas = new Ex1131 ( N , p ); canvas . setSize ( 400 , 400 ); frame . add ( canvas ); frame . pack (); frame . setVisible ( true ); } public void paint ( Graphics g ) { int radius = 100 ; double angle = Math . PI ; Point2D [] points = new Point2D . Double [ N ] ; for ( int i = 0 ; i < N ; i += 1 ) { angle = angle + Math . PI / 4 ; System . out . println ( angle ); double x = radius * Math . cos ( angle ) + 200 ; double y = radius * Math . sin ( angle ) + 200 ; g . fillOval (( int ) x , ( int ) y , 5 , 5 ); points [ i ] = new Point2D . Double ( x , y ); } g . setColor ( Color . GRAY ); for ( int i = 0 ; i < N ; i += 1 ) { for ( int j = i + 1 ; j < N ; j += 1 ) { if ( Math . random () < p ) { g . drawLine (( int ) points [ i ] . getX (), ( int ) points [ i ] . getY (), ( int ) points [ j ] . getX (), ( int ) points [ j ] . getY ()); } } } } } 1.1.32 \u00b6 Histogram. Suppose that the standard input stream is a sequence of double values. Write a program that takes an integer N and two double values l and r from the command line and uses StdDraw to plot a histogram of the count of the numbers in the standard input stream that fall in each of the N intervals defined by dividing (l , r) into N equal-sized intervals. public class Ex1132 extends Canvas { ArrayList nums ; int N ; double r ; double l ; Ex1132 ( int N , double r , double l , ArrayList nums ) { this . N = N ; this . r = r ; this . l = l ; this . nums = nums ; } public static void main ( String [] args ) { int N = Integer . parseInt ( args [ 0 ] ); double l = Double . parseDouble ( args [ 1 ] ); double r = Double . parseDouble ( args [ 2 ] ); ArrayList nums = new ArrayList < Integer > (); for ( int i = 3 ; i < args . length ; i += 1 ) { nums . add ( Integer . parseInt ( args [ i ] )); } JFrame frame = new JFrame ( \"Histogram\" ); Canvas canvas = new Ex1132 ( N , l , r , nums ); canvas . setSize ( 400 , 400 ); frame . add ( canvas ); frame . pack (); frame . setVisible ( true ); } public void paint ( Graphics g ) { int x = 30 ; int height = 400 ; int width = 300 ; // Draw a horizontal base line g . drawLine ( 10 , height - 45 , width - 10 , height - 45 ); int [] count = new int [ N ] ; for ( Iterator i = this . nums . iterator (); i . hasNext (); ) { int number = ( int ) i . next (); int intervalIndex = number / N ; count [ intervalIndex ] += 1 ; } // Find the maximum count. The maximum count has the highest bar int maxCount = 0 ; for ( int i = 0 ; i < count . length ; i ++ ) { if ( maxCount < count [ i ] ) maxCount = count [ i ] ; } for ( int i = 0 ; i < count . length ; i += 1 ) { // Find the bar height int barHeight = ( int ) ((( double ) count [ i ] / ( double ) maxCount ) * ( height - 55 )); // Display a bar (i.e. rectangle) g . drawRect ( x , height - 45 - barHeight , 10 , barHeight ); // Move x for displaying the next character x += N ; } } } 1.1.33 \u00b6 Matrix library. Write a library Matrix that implements the following API: public class Matrix static double dot ( double [] x , double [] y ) vector dot product static double [][] mult ( double [][] a , double [][] b ) matrix - matrix product static double [][] transpose ( double [][] a ) transpose static double [] mult ( double [][] a , double [] x ) matrix - vector product static double [] mult ( double [] y , double [][] a ) vector - matrix product Develop a test client that reads values from standard input and tests all the methods. public static int [][] mult ( int [][] firstMatrix , int [][] secondMatrix ) { int r1 = firstMatrix . length ; // row1 int r2 = firstMatrix [ 0 ] . length ; // col1 int q1 = secondMatrix . length ; // row2 int q2 = secondMatrix [ 0 ] . length ; // col2 int [][] product = new int [ r1 ][ q2 ] ; if ( r1 != q2 ) { return product ; } for ( int i = 0 ; i < r1 ; i ++ ) { for ( int j = 0 ; j < q2 ; j ++ ) { for ( int k = 0 ; k < c1 ; k ++ ) { product [ i ][ j ] += firstMatrix [ i ][ k ] * secondMatrix [ k ][ j ] ; } } } return product ; } static double dot ( double [] x , double [] y ) { double result = 0 ; for ( int k = 0 ; k < x . length ; k ++ ) { result += x [ k ] * y [ k ] ; } return result ; } static int [][] transpose ( int [][] arr ) { int [][] result = new int [ arr [ 0 ] . length ][ arr . length ] ; for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { result [ j ][ i ] = arr [ i ][ j ] ; } } return result ; } 1.1.34 \u00b6 Filtering. Which of the following require saving all the values from standard input (in an array, say), and which could be implemented as a filter using only a fixed number of variables and arrays of fixed size (not dependent on N)? For each, the input comes from standard input and consists of N real numbers between 0 and 1. Print the maximum and minimum numbers. Print the median of the numbers. Print the k th smallest value, for k less than 100. Print the sum of the squares of the numbers. Print the average of the N numbers. Print the percentage of numbers greater than the average. Print the N numbers in increasing order. Print the N numbers in random order. Require saving all the values from standard input: Print the maximum and minimum numbers. Print the median of the numbers. Print the k th smallest value, for k less than 100 Print the sum of the squares of the numbers Print the percentage of numbers greater than the average Implemented as a filter: 1. Print the average of the N numbers 2. Print the N numbers in random order 3. Print the N numbers in increasing order 1.1.35 \u00b6 Dice simulation. The following code computes the exact probability distribution for the sum of two dice: int SIDES = 6 ; double [] dist = new double [ 2 * SIDES + 1 ] ; for ( int i = 1 ; i <= SIDES ; i ++ ) for ( int j = 1 ; j <= SIDES ; j ++ ) dist [ i + j ] += 1.0 ; for ( int k = 2 ; k <= 2 * SIDES ; k ++ ) dist [ k ] /= 36.0 ; The value dist[i] is the probability that the dice sum to k. Run experiments to validate this calculation simulating N dice throws, keeping track of the frequencies of occurrence of each value when you compute the sum of two random integers between 1 and 6. How large does N have to be before your empirical results match the exact results to three decimal places? Using the code below: public static boolean areAllTrue ( boolean [] array ) { for ( boolean b : array ) if ( ! b ) return false ; return true ; } public static boolean allSimilar ( double [] distr , double [] freq ) { boolean [] equal = new boolean [ distr . length ] ; for ( int i = 0 ; i < distr . length ; i += 1 ) { BigDecimal aa = new BigDecimal ( distr [ i ] ); BigDecimal bb = new BigDecimal ( freq [ i ] ); aa = aa . setScale ( 3 , RoundingMode . HALF_EVEN ); bb = bb . setScale ( 3 , RoundingMode . HALF_EVEN ); equal [ i ] = aa . equals ( bb ); } return areAllTrue ( equal ); } public static void main ( String [] args ) { double [] distr = diceDistr (); double [] freq = new double [ 13 ] ; int trials = 1000 ; while ( ! allSimilar ( distr , freq ) && trials < 10 e6 ) { trials += 1000 ; for ( int i = 0 ; i < trials ; i += 1 ) { int randomNum1 = ThreadLocalRandom . current (). nextInt ( 1 , 7 ); int randomNum2 = ThreadLocalRandom . current (). nextInt ( 1 , 7 ); freq [ randomNum1 + randomNum2 ] += 1 ; } for ( int i = 0 ; i < freq . length ; i += 1 ) { freq [ i ] /= trials ; } } System . out . println ( trials ); } I managed to complete it after 297000 trials. It also depends on the rounding mode. 1.1.36 \u00b6 Empirical shuffle check. Run computational experiments to check that our shuffling code on page 32 works as advertised. Write a program ShuffleTest that takes command-line arguments M and N, does N shuffles of an array of size M that is initialized with a[i] = i before each shuffle, and prints an M-by-M table such that row i gives the number of times i wound up in position j for all j. All entries in the array should be close to N/M. 1.1.37 \u00b6 Bad shuffling. Suppose that you choose a random integer between 0 and N-1 in our shuffling code instead of one between i and N-1. Show that the resulting order is not equally likely to be one of the N! possibilities. Run the test of the previous exercise for this version. 1.1.38 \u00b6 Binary search versus brute-force search. Write a program BruteForceSearch that uses the brute-force search method given on page 48 and compare its running time on your computer with that of BinarySearch for largeW.txt and largeT.txt. static int bruteForceSearch ( int [] arr , int k ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == k ) return i ; } return - 1 ; } public static void main ( String [] args ) { int [] whitelist = readInts ( args [ 0 ] ); Arrays . sort ( whitelist ); Scanner s = new Scanner ( System . in ); long startTime = System . nanoTime (); while ( s . hasNext ()) { int key = s . nextInt (); if ( Arrays . binarySearch ( whitelist , key ) < 0 ) { System . out . println ( key ); } } long endTime = System . nanoTime (); long totalTime = endTime - startTime ; System . out . println ( totalTime ); } 1.1.39 \u00b6 Random matches. Write a BinarySearch client that takes an int value T as command-line argument and runs T trials of the following experiment for N = 103, 104, 105, and 106: generate two arrays of N randomly generated positive six-digit int values, and find the number of values that appear in both arrays. Print a table giving the average value of this quantity over the T trials for each value of N.","title":"1.1   Programming Model"},{"location":"Chap01/1.1/#111","text":"Give the value of each of the following expressions: a. ( 0 + 15 ) / 2 b. 2.0e-6 * 100000000.1 c. true && false || true && true a. jshell> (0 + 15) / 2 $1 ==> 7 b. jshell> 2.0e-6 * 100000000.1 $2 ==> 200.0000002 c. jshell> true && false || true && true $3 ==> true","title":"1.1.1"},{"location":"Chap01/1.1/#112","text":"Give the type and value of each of the following expressions: a. (1 + 2.236)/2 b. 1 + 2 + 3 + 4.0 c. 4.1 >= 4 d. 1 + 2 + \"3\" a. jshell> (1 + 2.236)/2 $1 ==> 1.618 jshell> ((Object)1.618).getClass().getName() $2 ==> \"java.lang.Double\" b. jshell> 1 + 2 + 3 + 4.0 $3 ==> 10.0 // Double c. jshell> 4.1 >= 4 $4 ==> true // Boolean d. jshell> 1 + 2 + \"3\" $5 ==> \"33\"","title":"1.1.2"},{"location":"Chap01/1.1/#113","text":"Write a program that takes three integer command-line arguments and prints equal if all three are equal, and not equal otherwise. public static void main ( String [] args ) { int first = Integer . parseInt ( args [ 0 ] ); int second = Integer . parseInt ( args [ 1 ] ); int third = Integer . parseInt ( args [ 2 ] ); if ( first == second && second == third ) { System . out . println ( \"equal\" ); } else { System . out . println ( \"not equal\" ); } }","title":"1.1.3"},{"location":"Chap01/1.1/#114","text":"What (if anything) is wrong with each of the following statements? a. if (a > b) then c = 0; b. if a > b { c = 0; } c. if (a > b) c = 0; d. if (a > b) c = 0 else b = 0; a. The programs does not compile. | Error: | variable declaration not allowed here | if (a > b) then c = 0; | ^---------^ b. The program fails to compile. | Error: | '(' expected | if a > b { c = 0; } | ^ | Error: | ')' expected | if a > b { c = 0; } | ^ c. The problem compiles. d. The problem does not compile. It's missing a semicolon; jshell> if (a > b) c = 0 else b = 0; | Error: | ';' expected | if (a > b) c = 0 else b = 0; |","title":"1.1.4"},{"location":"Chap01/1.1/#115","text":"Write a code fragment that prints true if the double variables x and y are both strictly between 0 and 1 and false otherwise. static boolean areBetween0and1 ( double x , double y ) { return isBetween0and1 ( x ) && isBetween0and1 ( y ); } static boolean isBetween0and1 ( double x ) { if ( x > 0 && x < 1 ) { return true ; } return false ; }","title":"1.1.5"},{"location":"Chap01/1.1/#116","text":"What does the following program print? int f = 0 ; int g = 1 ; for ( int i = 0 ; i <= 15 ; i ++ ) { StdOut . println ( f ); f = f + g ; g = f - g ; } It prints: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610","title":"1.1.6"},{"location":"Chap01/1.1/#117","text":"Give the value printed by each of the following code fragments: a . double t = 9.0 ; while ( Math . abs ( t - 9.0 / t ) > .001 ) t = ( 9.0 / t + t ) / 2.0 ; StdOut . printf ( \"%.5f\\n\" , t ); b . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); c . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i *= 2 ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); a) 3.00009 b) 499500 c) 1023","title":"1.1.7"},{"location":"Chap01/1.1/#118","text":"What do each of the following print? a. System.out.println('b'); b. System.out.println('b' + 'c'); c. System.out.println((char) ('a' + 4)); Explain each outcome. a) It prints 'b' and a new line b) It prints 197. First 'b' is converted to int (98) and then 'c' to int (99) so the total is 98 + 99 = 197 c) It prints 'e'. First ('a' + 4) is converted to int. 'a' is 97 so result is 97 + 4 = 101. Then this int is converted to char which is 'e';","title":"1.1.8"},{"location":"Chap01/1.1/#1111","text":"Write a code fragment that prints the contents of a two-dimensional boolean array, using * to represent true and a space to represent false. Include row and column numbers. static void printContents ( boolean [][] arr ) { for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { if ( arr [ i ][ j ] ) { System . out . printf ( \"row: %d, column: %d = *\\n\" , i , j ); } else { System . out . printf ( \"row: %d, column: %d = \\n\" , i , j ); } } } }","title":"1.1.11"},{"location":"Chap01/1.1/#1112","text":"What does the following code fragment print? int [] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = 9 - i ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = a [ a [ i ]] ; for ( int i = 0 ; i < 10 ; i ++ ) System . out . println ( i ); It prints: 0 1 2 3 4 5 6 7 8 9","title":"1.1.12"},{"location":"Chap01/1.1/#1113","text":"Write a code fragment to print the transposition (rows and columns changed) of a two-dimensional array with M rows and N columns. static void printTranspose ( int [][] arr ) { int [][] result = new int [ arr [ 0 ] . length ][ arr . length ] ; for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { result [ j ][ i ] = arr [ i ][ j ] ; } } for ( int i = 0 ; i < result . length ; i += 1 ) { for ( int j = 0 ; j < result [ i ] . length ; j += 1 ) { System . out . printf ( \"row: %d, column: %d = %d\\n\" , i , j , result [ i ][ j ] ); } } }","title":"1.1.13"},{"location":"Chap01/1.1/#1114","text":"Write a static method lg() that takes an int value N as argument and returns the largest int not larger than the base-2 logarithm of N. Do not use Math. static int lg ( int n ) { if ( n == 1 ) { return 0 ; } if ( n == 2 ) { return 1 ; } int acc = 2 ; int result = 1 ; while ( acc * 2 <= n ) { acc *= 2 ; result += 1 ; } return result ; }","title":"1.1.14"},{"location":"Chap01/1.1/#1115","text":"Write a static method histogram() that takes an array a[] of int values and an integer M as arguments and returns an array of length M whose ith entry is the number of times the integer i appeared in the argument array. If the values in a[] are all between 0 and M\u20131, the sum of the values in the returned array should be equal to a.length. static int [] histogram ( int [] arr , int M ) { int [] result = new int [ M ] ; for ( int i : arr ) { if ( i < M ) { result [ i ] += 1 ; } } return result ; }","title":"1.1.15"},{"location":"Chap01/1.1/#1116","text":"Give the value of exR1(6): public static String exR1 ( int n ) { if ( n <= 0 ) return \"\" ; return exR1 ( n - 3 ) + n + exR1 ( n - 2 ) + n ; } Result is 311361142246","title":"1.1.16"},{"location":"Chap01/1.1/#1118","text":"Consider the following recursive function: public static int mystery ( int a , int b ) { if ( b == 0 ) return 0 ; if ( b % 2 == 0 ) return mystery ( a + a , b / 2 ); return mystery ( a + a , b / 2 ) + a ; } What are the values of mystery(2, 25) and mystery(3, 11)? Given positive integers a and b, describe what value mystery(a, b) computes. Answer the same question, but replace + with * and replace return 0 with return 1. mystery(2, 25) prints 2 * 25 = 50 mystery(3, 11) prints 3 * 11 = 33 mystery indeed computes $a * b$; If we replace + with * and 0 with 1 the fuction becomes: public static int mystery ( int a , int b ) { if ( b == 0 ) return 1 ; if ( b % 2 == 0 ) return mystery ( a * a , b / 2 ); return mystery ( a * a , b / 2 ) * a ; } This computes the value $a^b$.","title":"1.1.18"},{"location":"Chap01/1.1/#1119","text":"Run the following program on your computer: public class Fibonacci { public static long F ( int N ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return 1 ; return F ( N - 1 ) + F ( N - 2 ); } public static void main ( String [] args ) { for ( int N = 0 ; N < 100 ; N ++ ) StdOut . println ( N + \" \" + F ( N )); } } What is the largest value of N for which this program takes less 1 hour to compute the value of F(N)? Develop a better implementation of F(N) that saves computed values in an array. On my machine any values more than 50 resulted in really slow computation. Here is a better version (using longs): public static long F ( long N ) { if ( N <= 1 ) { return N ; } long [] memo = new long [ ( int )( N + 1 ) ] ; memo [ 0 ] = 0 ; memo [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i += 1 ) { memo [ i ] = memo [ i - 1 ] + memo [ i - 2 ] ; } return memo [ ( int ) N ] ; }","title":"1.1.19"},{"location":"Chap01/1.1/#1120","text":"Write a recursive static method that computes the value of ln (N !) Since $n! = 1 \u00d7 2 \u00d7 3 \u00d7 ... \u00d7 n$, then $ log(n!) = log(1) + log(2) + log(3) + \u2026 + log(n)$. Computing this for large values of n is costly. Since we are not asked for an approximation we can just calculate it directly. (using the lg function we implemented earlier) static int lnProduct ( int n ) { if ( n == 1 ) { return 0 ; } return lg ( n ) + lnProduct ( n - 1 ); }","title":"1.1.20"},{"location":"Chap01/1.1/#1121","text":"Write a program that reads in lines from standard input with each line containing a name and two integers and then uses printf() to print a table with a column of the names, the integers, and the result of dividing the first by the second, accurate to three decimal places. You could use a program like this to tabulate batting averages for baseball players or grades for students. public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); while ( input . hasNextLine ()) { String line = input . nextLine (); String [] words = line . split ( \" \" ); String name = words [ 0 ] ; double first = Double . parseDouble ( words [ 1 ] ); double second = Double . parseDouble ( words [ 2 ] ); System . out . printf ( \"Name: %s, Div: %.3f\\n\" , name , first / second ); } }","title":"1.1.21"},{"location":"Chap01/1.1/#1122","text":"Write a version of BinarySearch that uses the recursive rank() given on page 25 and traces the method calls. Each time the recursive method is called, print the argument values lo and hi, indented by the depth of the recursion. Hint: Add an argument to the recursive method that keeps track of the depth. public static int rank ( int key , int [] a ) { return rank ( key , a , 0 , a . length - 1 , 0 ); } public static String padLeft ( String inputString , int length ) { StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < length ; i ++ ) { sb . append ( ' ' ); } return sb . toString () + inputString ; } public static int rank ( int key , int [] a , int lo , int hi , int depth ) { String out = padLeft ( String . format ( \"lo: %d, hi: %d\\n\" , lo , hi ), depth ); System . out . print ( out ); if ( lo > hi ) return - 1 ; int mid = lo + ( hi - lo ) / 2 ; if ( key < a [ mid ] ) return rank ( key , a , lo , mid - 1 , depth + 1 ); else if ( key > a [ mid ] ) return rank ( key , a , mid + 1 , hi , depth + 1 ); else return mid ; } 1.1.23 Add to the BinarySearch test client the ability to respond to a second argument: + to print numbers from standard input that are not in the whitelist, - to print numbers that are in the whitelist. public static void main ( String [] args ) { int [] whitelist = readInts ( args [ 0 ] ); boolean printNotFromWhitelist = true ; if ( args [ 1 ] . equals ( \"+\" )) { printNotFromWhitelist = true ; } if ( args [ 1 ] . equals ( \"-\" )) { printNotFromWhitelist = false ; } Scanner scanner = new Scanner ( System . in ); Arrays . sort ( whitelist ); while ( scanner . hasNext ()) { // Read key, print if not in whitelist. int key = scanner . nextInt (); boolean notFound = rank ( key , whitelist ) < 0 ; // Print numbers from standard input that are not in the whitelist if ( notFound && printNotFromWhitelist ) { System . out . println ( key ); } // Print numbers from standard input that are in the whitelist if ( ! notFound && ! printNotFromWhitelist ) { System . out . println ( key ); } } }","title":"1.1.22"},{"location":"Chap01/1.1/#1124","text":"Give the sequence of values of p and q that are computed when Euclid\u2019s algorithm is used to compute the greatest common divisor of 105 and 24. Extend the code given on page 4 to develop a program Euclid that takes two integers from the command line and computes their greatest common divisor, printing out the two arguments for each call on the recursive method. Use your program to compute the greatest common divisor or 1111111 and 1234567. Solution trivial...","title":"1.1.24"},{"location":"Chap01/1.1/#1125","text":"Use mathematical induction to prove that Euclid\u2019s algorithm computes the greatest common divisor of any pair of nonnegative integers p and q. In GCD the process terminates when a remainder of 0 is reached, and the last nonzero remainder in the process is gcd(p, q) with $p \u2265 q$ The process in the Euclidean algorithm produces a strictly decreasing sequence of remainders $r0 > r1 > r2 > \u00b7 \u00b7 \u00b7 >rn+1 = 0$ Hence the algorithm stops after no more than q divisions. If $rn$ is the last non-zero remainder in the process, then we have $rn = gcd(rn, 0) = gcd(rn\u22121, rn) = ... = gcd(r0, r1) = gcd(p, q).$ For the base step $i = 0$, we have $gcd(p, q) = gcd(r0, r1)$ by definition of $r0 = a$ and $r1 = b$. For each i in 0 \u2264 i < n we have $gcd(ri, ri+1) = gcd(ri+1, ri+2)$ This shows that if $gcd(a, b) = gcd(ri, ri+1)$, then $gcd(a, b) = gcd(ri+1, ri+2),$ which is the induction step.","title":"1.1.25"},{"location":"Chap01/1.1/#1126","text":"Sorting three numbers. Suppose that the variables a, b, c, and t are all of the same numeric primitive type. Show that the following code puts a, b, and c in ascending order: if ( a > b ) { t = a ; a = b ; b = t ; } if ( a > c ) { t = a ; a = c ; c = t ; } if ( b > c ) { t = b ; b = c ; c = t ; } The first if checks if $a > b$ and swaps $a$ with $b$. At the end we have $a < b$; The second if checks if $a > c$ and swaps $a$ with $c$. At the end we have $a < c$; The last if checks if $b > c$ and swaps $b$ with $c$. At the end we have $b < c$; From all three we have $a < b < c$. For example if $a=3, b=2, c=1$ we have: $3 > 2$ then $a = 2, b = 3$ $2 > 1$ then $a = 1, c = 2$ $3 > 2$ then $c = 3, b = 2$","title":"1.1.26"},{"location":"Chap01/1.1/#1127","text":"Binomial distribution. Estimate the number of recursive calls that would be used by the code: public static double binomial ( int N , int k , double p ) { if (( N == 0 ) || ( k < 0 )) return 1.0 ; return ( 1.0 - p ) * binomial ( N - 1 , k ) + p * binomial ( N - 1 , k - 1 ); } to compute binomial(100, 50). Develop a better implementation that is based on saving computed values in an array. Code seems to be wrong! We don't have a definition of binomial with two parameters! The code should have been: static int nChoseR ( int n , int r ) { // Since nCr is same as nC(n-r) // To decrease number of iterations if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ); answer /= i ; } return answer ; } static float binomialProbability ( int n , int k , float p ) { return nChoseR ( n , k ) * ( float ) Math . pow ( p , k ) * ( float ) Math . pow ( 1 - p , n - k ); }","title":"1.1.27"},{"location":"Chap01/1.1/#1128","text":"Remove duplicates. Modify the test client in BinarySearch to remove any duplicate keys in the whitelist after the sort. When you find one of the indexes you're looking for, and from there, then check all the left and right indexes for the same value and remove them from the array public static void main ( String [] args ) { int [] whitelist = In . readInts ( args [ 0 ] ); Arrays . sort ( whitelist ); while ( ! StdIn . isEmpty ()) { // Read key, print if not in whitelist. int key = StdIn . readInt (); int index = rank ( key , whitelist ); // finds index of duplicate if ( index >= 0 ) { int start = index - 1 , end = index + 1 ; // Check left of index while ( start != 0 && whitelist [ start ] == key ) { if ( whitelist [ start ] == key ) { start -= 1 ; } else { break ; } } // Check right of index while ( end != whitelist . length - 1 ) { if ( whitelist [ end ] == key ) { end += 1 ; } else { break ; } } int numOfDuplicates = end - start ; if ( numOfDuplicates > 0 ) { // Copy first part int [] first = Arrays . copyOfRange ( whitelist , 0 , start ); // Copy second part int [] second = Arrays . copyOfRange ( whitelist , end + 1 , whitelist . length - 1 ); // Create result array with no duplicate keys int [] result = new int [ first . length + second . length + 1 ] ; System . arraycopy ( first , 0 , result , 0 , first . length ); // Assign key in position result [ first . length ] = key ; // Combine the results System . arraycopy ( second , 0 , result , first . length + 1 , second . length ); whitelist = result ; } } } }","title":"1.1.28"},{"location":"Chap01/1.1/#1129","text":"Equal keys. Add to BinarySearch a static method rank() that takes a key and a sorted array of int values (some of which may be equal) as arguments and returns the number of elements that are smaller than the key and a similar method count() that returns the number of elements equal to the key. Note : If i and j are the values returned by rank(key, a) and count(key, a) respectively, then a[i..i+j-1] are the values in the array that are equal to key. /* Returns the number of elements that are smaller than the key */ static int rank ( int key , int [] a ) { int index = Arrays . binarySearch ( a , key ); int lessThanCount = 0 ; if ( index >= 0 ) { int curr = index - 1 ; while ( curr >= 0 ) { if ( a [ curr ] != key ) { lessThanCount += 1 ; } curr -= 1 ; } } return lessThanCount ; } /* Returns the number of elements equal to the key */ static int count ( int key , int [] a ) { int index = Arrays . binarySearch ( a , key ); int count = 0 ; if ( index >= 0 ) { count += 1 ; int start = index - 1 , end = index + 1 ; // Check left of index while ( start >= 0 ) { if ( a [ start ] == key ) { start -= 1 ; count += 1 ; } else { break ; } } // Check right of index while ( end < a . length - 1 ) { if ( a [ end ] == key ) { end += 1 ; count += 1 ; } else { break ; } } } return count ; }","title":"1.1.29"},{"location":"Chap01/1.1/#1130","text":"Array exercise. Write a code fragment that creates an N-by-N boolean array a[][] such that a[i][j] is true if i and j are relatively prime (have no common factors), and false otherwise. If the greatest common divisor (gcd) of 2 numbers a and b is 1 (i.e. gcd(a, b) = 1) then a and b are relatively prime. static boolean [][] relPrimeTable ( int N ) { boolean [][] result = new boolean [ N ][ N ] ; for ( int i = 0 ; i < N ; i += 1 ) { for ( int j = 0 ; j < N ; j += 1 ) { result [ i ][ j ] = gcd ( i , j ) == 1 ; } } return result ; }","title":"1.1.30"},{"location":"Chap01/1.1/#1131","text":"Random connections. Write a program that takes as command-line arguments an integer N and a double value p (between 0 and 1), plots N equally spaced dots of size .05 on the circumference of a circle, and then, with probability p for each pair of points, draws a gray line connecting them. public class Ex1131 extends Canvas { int N ; double p ; Ex1131 ( int N , double p ) { this . N = N ; this . p = p ; } public static void main ( String [] args ) { int N = Integer . parseInt ( args [ 0 ] ); double p = Double . parseDouble ( args [ 1 ] ); JFrame frame = new JFrame ( \"Random Connections\" ); Canvas canvas = new Ex1131 ( N , p ); canvas . setSize ( 400 , 400 ); frame . add ( canvas ); frame . pack (); frame . setVisible ( true ); } public void paint ( Graphics g ) { int radius = 100 ; double angle = Math . PI ; Point2D [] points = new Point2D . Double [ N ] ; for ( int i = 0 ; i < N ; i += 1 ) { angle = angle + Math . PI / 4 ; System . out . println ( angle ); double x = radius * Math . cos ( angle ) + 200 ; double y = radius * Math . sin ( angle ) + 200 ; g . fillOval (( int ) x , ( int ) y , 5 , 5 ); points [ i ] = new Point2D . Double ( x , y ); } g . setColor ( Color . GRAY ); for ( int i = 0 ; i < N ; i += 1 ) { for ( int j = i + 1 ; j < N ; j += 1 ) { if ( Math . random () < p ) { g . drawLine (( int ) points [ i ] . getX (), ( int ) points [ i ] . getY (), ( int ) points [ j ] . getX (), ( int ) points [ j ] . getY ()); } } } } }","title":"1.1.31"},{"location":"Chap01/1.1/#1132","text":"Histogram. Suppose that the standard input stream is a sequence of double values. Write a program that takes an integer N and two double values l and r from the command line and uses StdDraw to plot a histogram of the count of the numbers in the standard input stream that fall in each of the N intervals defined by dividing (l , r) into N equal-sized intervals. public class Ex1132 extends Canvas { ArrayList nums ; int N ; double r ; double l ; Ex1132 ( int N , double r , double l , ArrayList nums ) { this . N = N ; this . r = r ; this . l = l ; this . nums = nums ; } public static void main ( String [] args ) { int N = Integer . parseInt ( args [ 0 ] ); double l = Double . parseDouble ( args [ 1 ] ); double r = Double . parseDouble ( args [ 2 ] ); ArrayList nums = new ArrayList < Integer > (); for ( int i = 3 ; i < args . length ; i += 1 ) { nums . add ( Integer . parseInt ( args [ i ] )); } JFrame frame = new JFrame ( \"Histogram\" ); Canvas canvas = new Ex1132 ( N , l , r , nums ); canvas . setSize ( 400 , 400 ); frame . add ( canvas ); frame . pack (); frame . setVisible ( true ); } public void paint ( Graphics g ) { int x = 30 ; int height = 400 ; int width = 300 ; // Draw a horizontal base line g . drawLine ( 10 , height - 45 , width - 10 , height - 45 ); int [] count = new int [ N ] ; for ( Iterator i = this . nums . iterator (); i . hasNext (); ) { int number = ( int ) i . next (); int intervalIndex = number / N ; count [ intervalIndex ] += 1 ; } // Find the maximum count. The maximum count has the highest bar int maxCount = 0 ; for ( int i = 0 ; i < count . length ; i ++ ) { if ( maxCount < count [ i ] ) maxCount = count [ i ] ; } for ( int i = 0 ; i < count . length ; i += 1 ) { // Find the bar height int barHeight = ( int ) ((( double ) count [ i ] / ( double ) maxCount ) * ( height - 55 )); // Display a bar (i.e. rectangle) g . drawRect ( x , height - 45 - barHeight , 10 , barHeight ); // Move x for displaying the next character x += N ; } } }","title":"1.1.32"},{"location":"Chap01/1.1/#1133","text":"Matrix library. Write a library Matrix that implements the following API: public class Matrix static double dot ( double [] x , double [] y ) vector dot product static double [][] mult ( double [][] a , double [][] b ) matrix - matrix product static double [][] transpose ( double [][] a ) transpose static double [] mult ( double [][] a , double [] x ) matrix - vector product static double [] mult ( double [] y , double [][] a ) vector - matrix product Develop a test client that reads values from standard input and tests all the methods. public static int [][] mult ( int [][] firstMatrix , int [][] secondMatrix ) { int r1 = firstMatrix . length ; // row1 int r2 = firstMatrix [ 0 ] . length ; // col1 int q1 = secondMatrix . length ; // row2 int q2 = secondMatrix [ 0 ] . length ; // col2 int [][] product = new int [ r1 ][ q2 ] ; if ( r1 != q2 ) { return product ; } for ( int i = 0 ; i < r1 ; i ++ ) { for ( int j = 0 ; j < q2 ; j ++ ) { for ( int k = 0 ; k < c1 ; k ++ ) { product [ i ][ j ] += firstMatrix [ i ][ k ] * secondMatrix [ k ][ j ] ; } } } return product ; } static double dot ( double [] x , double [] y ) { double result = 0 ; for ( int k = 0 ; k < x . length ; k ++ ) { result += x [ k ] * y [ k ] ; } return result ; } static int [][] transpose ( int [][] arr ) { int [][] result = new int [ arr [ 0 ] . length ][ arr . length ] ; for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { result [ j ][ i ] = arr [ i ][ j ] ; } } return result ; }","title":"1.1.33"},{"location":"Chap01/1.1/#1134","text":"Filtering. Which of the following require saving all the values from standard input (in an array, say), and which could be implemented as a filter using only a fixed number of variables and arrays of fixed size (not dependent on N)? For each, the input comes from standard input and consists of N real numbers between 0 and 1. Print the maximum and minimum numbers. Print the median of the numbers. Print the k th smallest value, for k less than 100. Print the sum of the squares of the numbers. Print the average of the N numbers. Print the percentage of numbers greater than the average. Print the N numbers in increasing order. Print the N numbers in random order. Require saving all the values from standard input: Print the maximum and minimum numbers. Print the median of the numbers. Print the k th smallest value, for k less than 100 Print the sum of the squares of the numbers Print the percentage of numbers greater than the average Implemented as a filter: 1. Print the average of the N numbers 2. Print the N numbers in random order 3. Print the N numbers in increasing order","title":"1.1.34"},{"location":"Chap01/1.1/#1135","text":"Dice simulation. The following code computes the exact probability distribution for the sum of two dice: int SIDES = 6 ; double [] dist = new double [ 2 * SIDES + 1 ] ; for ( int i = 1 ; i <= SIDES ; i ++ ) for ( int j = 1 ; j <= SIDES ; j ++ ) dist [ i + j ] += 1.0 ; for ( int k = 2 ; k <= 2 * SIDES ; k ++ ) dist [ k ] /= 36.0 ; The value dist[i] is the probability that the dice sum to k. Run experiments to validate this calculation simulating N dice throws, keeping track of the frequencies of occurrence of each value when you compute the sum of two random integers between 1 and 6. How large does N have to be before your empirical results match the exact results to three decimal places? Using the code below: public static boolean areAllTrue ( boolean [] array ) { for ( boolean b : array ) if ( ! b ) return false ; return true ; } public static boolean allSimilar ( double [] distr , double [] freq ) { boolean [] equal = new boolean [ distr . length ] ; for ( int i = 0 ; i < distr . length ; i += 1 ) { BigDecimal aa = new BigDecimal ( distr [ i ] ); BigDecimal bb = new BigDecimal ( freq [ i ] ); aa = aa . setScale ( 3 , RoundingMode . HALF_EVEN ); bb = bb . setScale ( 3 , RoundingMode . HALF_EVEN ); equal [ i ] = aa . equals ( bb ); } return areAllTrue ( equal ); } public static void main ( String [] args ) { double [] distr = diceDistr (); double [] freq = new double [ 13 ] ; int trials = 1000 ; while ( ! allSimilar ( distr , freq ) && trials < 10 e6 ) { trials += 1000 ; for ( int i = 0 ; i < trials ; i += 1 ) { int randomNum1 = ThreadLocalRandom . current (). nextInt ( 1 , 7 ); int randomNum2 = ThreadLocalRandom . current (). nextInt ( 1 , 7 ); freq [ randomNum1 + randomNum2 ] += 1 ; } for ( int i = 0 ; i < freq . length ; i += 1 ) { freq [ i ] /= trials ; } } System . out . println ( trials ); } I managed to complete it after 297000 trials. It also depends on the rounding mode.","title":"1.1.35"},{"location":"Chap01/1.1/#1136","text":"Empirical shuffle check. Run computational experiments to check that our shuffling code on page 32 works as advertised. Write a program ShuffleTest that takes command-line arguments M and N, does N shuffles of an array of size M that is initialized with a[i] = i before each shuffle, and prints an M-by-M table such that row i gives the number of times i wound up in position j for all j. All entries in the array should be close to N/M.","title":"1.1.36"},{"location":"Chap01/1.1/#1137","text":"Bad shuffling. Suppose that you choose a random integer between 0 and N-1 in our shuffling code instead of one between i and N-1. Show that the resulting order is not equally likely to be one of the N! possibilities. Run the test of the previous exercise for this version.","title":"1.1.37"},{"location":"Chap01/1.1/#1138","text":"Binary search versus brute-force search. Write a program BruteForceSearch that uses the brute-force search method given on page 48 and compare its running time on your computer with that of BinarySearch for largeW.txt and largeT.txt. static int bruteForceSearch ( int [] arr , int k ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == k ) return i ; } return - 1 ; } public static void main ( String [] args ) { int [] whitelist = readInts ( args [ 0 ] ); Arrays . sort ( whitelist ); Scanner s = new Scanner ( System . in ); long startTime = System . nanoTime (); while ( s . hasNext ()) { int key = s . nextInt (); if ( Arrays . binarySearch ( whitelist , key ) < 0 ) { System . out . println ( key ); } } long endTime = System . nanoTime (); long totalTime = endTime - startTime ; System . out . println ( totalTime ); }","title":"1.1.38"},{"location":"Chap01/1.1/#1139","text":"Random matches. Write a BinarySearch client that takes an int value T as command-line argument and runs T trials of the following experiment for N = 103, 104, 105, and 106: generate two arrays of N randomly generated positive six-digit int values, and find the number of values that appear in both arrays. Print a table giving the average value of this quantity over the T trials for each value of N.","title":"1.1.39"},{"location":"Chap01/1.2/","text":"1.2.1 \u00b6 Write a Point2D client that takes an integer value N from the command line, generates N random points in the unit square, and computes the distance separating the closest pair of points. Brute force approach: public class Ex121 { int N ; public static void main ( String [] args ) { int N = Integer . parseInt ( args [ 0 ] ); Point2D . Double [] points = new Point2D . Double [ N ] ; for ( int i = 0 ; i < N ; i += 1 ) { double x = ThreadLocalRandom . current (). nextDouble ( 0 , 400 ); double y = ThreadLocalRandom . current (). nextDouble ( 0 , 400 ); points [ i ] = new Point2D . Double ( x , y ); } System . out . println ( findClosestPairsBruteForce ( points )); } static double dist ( Point2D p1 , Point2D p2 ) { return Math . sqrt (( p1 . getX () - p2 . getY ()) * ( p1 . getX () - p2 . getX ()) + ( p1 . getY () - p2 . getY ()) * ( p1 . getY () - p2 . getY ()) ); } static double findClosestPairsBruteForce ( Point2D [] points ) { double min = Double . MAX_VALUE ; for ( int i = 0 ; i < points . length ; i += 1 ) for ( int j = i + 1 ; j < points . length ; j += 1 ) if ( dist ( points [ i ] , points [ j ] ) < min ) min = dist ( points [ i ] , points [ j ] ); return min ; } } 1.2.2 \u00b6 Write an Interval1D client that takes an int value N as command-line argument, reads N intervals (each defined by a pair of double values) from standard input, and prints all pairs that intersect. TODO 1.2.3 \u00b6 Write an Interval2D client that takes command-line arguments N, min, and max and generates N random 2D intervals whose width and height are uniformly distributed between min and max in the unit square. Draw them on StdDraw and print the number of pairs of intervals that intersect and the number of intervals that are contained in one another. TODO 1.2.6 \u00b6 A string s is a circular rotation of a string t if it matches when the characters are circularly shifted by any number of positions; e.g., ACTGACG is a circular shift of TGACGAC, and vice versa. Detecting this condition is important in the study of genomic sequences. Write a program that checks whether two given strings s and t are circular shifts of one another. Hint : The solution is a one-liner with indexOf(), length(), and string concatenation. Solution is based from this article : static boolean isCircular ( String a , String b ) { boolean result = false ; if ( a == null || b == null ) { return false ; } if ( a . length () != b . length ()) { return false ; } String combined = a + a ; if ( combined . indexOf ( b ) >= 0 ) { result = true ; } return result ; } 1.2.7 \u00b6 What does the following recursive function return? public static String mystery ( String s ){ int N = s . length (); if ( N <= 1 ) return s ; String a = s . substring ( 0 , N / 2 ); String b = s . substring ( N / 2 , N ); return mystery ( b ) + mystery ( a ); } It reverses the provided string. For example ABCDEFG becomes GFEDCBA . 1.2.9 \u00b6 Instrument BinarySearch (page 47) to use a Counter to count the total number of keys examined during all searches and then print the total after all searches are complete. Hint : Create a Counter in main() and pass it as an argument to rank(). public static int rank ( int key , int [] a , Counter c ) { return rank ( key , a , 0 , a . length - 1 , c ); } public static int rank ( int key , int [] a , int lo , int hi , Counter c ) { if ( lo > hi ) return - 1 ; int mid = lo + ( hi - lo ) / 2 ; if ( key < a [ mid ] ) { c . increment (); return rank ( key , a , lo , mid - 1 , c ); } else if ( key > a [ mid ] ) { c . increment (); return rank ( key , a , mid + 1 , hi , c ); } else return mid ; } 1.2.10 \u00b6 Develop a class VisualCounter that allows both increment and decrement operations. Take two arguments N and max in the constructor, where N specifies the maximum number of operations and max specifies the maximum absolute value for the counter. As a side effect, create a plot showing the value of the counter each time its tally changes. static class VisualCounter { private final String name ; // counter name private int count = 0 ; // current value private int N = 0 ; // maximum number of operations private int max = 0 ; // maximum absolute value for the counter private int opCount = 0 ; // current operations count public VisualCounter ( String id , int N , int max ) { name = id ; this . N = N ; this . max = max ; } public void increment () { if ( opCount < N && count < max ) { count ++ ; opCount += 1 ; } } public void decrement () { opCount += 1 ; count -- ; } public int tally () { return count ; } public String toString () { return count + \" \" + name ; } } 1.2.11 \u00b6 Develop an implementation SmartDate of our Date API that raises an exception if the date is not legal. We just add a simple validation for invalid day/year/month combinations public class SmartDate { private final int month ; private final int day ; private final int year ; public SmartDate ( int m , int d , int y ) throws IllegalArgumentException { validateDate ( m , d , y ); month = m ; day = d ; year = y ; } public int month () { return month ; } public int day () { return day ; } public int year () { return year ; } public String toString () { return month () + \"/\" + day () + \"/\" + year (); } boolean isLeapYear ( int year ) { return year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ); } public boolean equals ( Object x ) { if ( this == x ) return true ; if ( x == null ) return false ; if ( this . getClass () != x . getClass ()) return false ; Date that = ( Date ) x ; if ( this . day != that . day ) return false ; if ( this . month != that . month ) return false ; if ( this . year != that . year ) return false ; return true ; } private void validateDate ( int m , int d , int y ) throws IllegalArgumentException { if ( m > 12 || m < 1 ) { throw new IllegalArgumentException ( \"Invalid Month\" ); } if ( d > 31 || d < 1 ) { throw new IllegalArgumentException ( \"Invalid Day\" ); } if ( isLeapYear ( y ) && m == 2 && d > 29 ) { throw new IllegalArgumentException ( \"Invalid Day\" ); } } } 1.2.12 \u00b6 Add a method dayOfTheWeek() to SmartDate that returns a String value Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, or Sunday, giving the appropriate day of the week for the date. You may assume that the date is in the 21st century A nice hack: public static String getDay ( int day , int month , int year ) { String dayOfWeek = null ; String [] days = { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" }; String date = String . valueOf ( day ) + \"/\" + String . valueOf ( month ) + \"/\" + String . valueOf ( year ); try { SimpleDateFormat format1 = new SimpleDateFormat ( \"d/M/yyyy\" ); Date dt1 = format1 . parse ( date ); dayOfWeek = days [ dt1 . getDay () - 1 ] ; } catch ( Exception e ) { System . out . println ( e ); } return dayOfWeek ; } 1.2.13 \u00b6 Using our implementation of Date as a model (page 91), develop an implementation of Transaction. class Transaction implements Comparable < Transaction > { String who ; Date when ; double amount ; Transaction ( String who , Date when , double amount ) { this . who = who ; this . when = when ; this . amount = amount ; } String who () { return who ; } Date when () { return when ; } double getAmount () { return amount ; } @Override public String toString () { StringBuilder s = new StringBuilder (); s . append ( \"<Transaction \" ); s . append ( \"who=\" + who ); s . append ( \" when=\" + when ); s . append ( \" amount=\" + amount ); s . append ( \">\" ); return s . toString (); } @Override public boolean equals ( Object that ) { // If the object is compared with itself then return true if ( that == this ) { return true ; } if ( ! ( that instanceof Transaction )) { return false ; } Transaction t = ( Transaction ) that ; // Compare the data members and return accordingly return Double . compare ( amount , t . getAmount ()) == 0 && t . who == who && when == t . when ; } @Override public int hashCode () { int result = 17 ; result = 31 * result + ( int ) amount ; result = 31 * result + when . hashCode (); result = 31 * result + who . hashCode (); return result ; } @Override public int compareTo ( Transaction that ) { if ( when . compareTo ( that . when ) < 0 ) return - 1 ; if ( when . compareTo ( that . when ) > 0 ) { return 1 ; } // Transaction is identical: compare amount and who if ( this . amount < that . amount ) { return - 1 ; } else if ( this . amount > that . amount ) { return 1 ; } else { return who . compareTo ( that . who ); } } } 1.2.14 \u00b6 Using our implementation of equals() in Date as a model (page 103), develop implementations of equals() for Transaction. Done in 1.2.23 1.2.16 \u00b6 Rational numbers. Implement an immutable data type Rational for rational numbers that supports addition, subtraction, multiplication, and division. public class Rational Rational ( int numerator . int denominator ) Rational plus ( Rational b ) sum of this number and b Rational minus ( Rational b ) difference of this number and b Rational times ( Rational b ) product of this number and b Rational divides ( Rational b ) quotient of this number and b boolean equals ( Rational that ) is this number equal to that ? String toString () string representation You do not have to worry about testing for overflow (see Exercise 1.2.17), but use as instance variables two long values that represent the numerator and denominator to limit the possibility of overflow. Use Euclid\u2019s algorithm (see page 4) to ensure that the numerator and denominator never have any common factors. Include a test client that exercises all of your methods. static class Rational { int numerator ; int denominator ; Rational ( int numerator , int denominator ) { this . numerator = numerator ; this . denominator = denominator ; } Rational plus ( Rational b ) { if ( denominator == b . denominator ) { return new Rational ( numerator + b . numerator , denominator ); } int lcmNumber = lcm ( denominator , b . denominator ); int timesFirst = lcmNumber / denominator ; int timesSecond = lcmNumber / b . denominator ; return new Rational (( timesFirst * numerator ) + ( timesSecond * b . numerator ), lcmNumber ); } Rational minus ( Rational b ) { if ( denominator == b . denominator ) { return new Rational ( numerator - b . numerator , denominator ); } int lcmNumber = lcm ( denominator , b . denominator ); int timesFirst = lcmNumber / denominator ; int timesSecond = lcmNumber / b . denominator ; return new Rational (( timesFirst * numerator ) - ( timesSecond * b . numerator ), lcmNumber ); } public boolean equals ( Rational that ) { return denominator == that . denominator && numerator == that . numerator ; } Rational times ( Rational b ) { int newNuminator = numerator * b . numerator ; int newDenuminator = denominator * b . denominator ; return new Rational ( newNuminator , newDenuminator ); } Rational divides ( Rational b ) { Rational reciprocal = new Rational ( b . denominator , b . numerator ); // Ignore simplification step... return times ( reciprocal ); } @Override public String toString () { return \"Rational{\" + \"numerator=\" + numerator + \", denominator=\" + denominator + '}' ; } 1.2.17 \u00b6 Robust implementation of rational numbers. Use assertions to develop an implementation of Rational (see Exercise 1.2.16) that is immune to overflow. TODO 1.2.18 \u00b6 Variance for accumulator. Validate that the following code, which adds the methods var() and stddev() to Accumulator, computes both the mean and variance of the numbers presented as arguments to addDataValue(): public class Accumulator { private double m ; private double s ; private int N ; public void addDataValue ( double x ) { N ++ ; s = s + 1.0 * ( N - 1 ) / N * ( x - m ) * ( x - m ); m = m + ( x - m ) / N ; } public double mean () { return m ; } public double var () { return s / ( N - 1 ); } public double stddev () { return Math . sqrt ( this . var ()); } } This implementation is less susceptible to roundoff error than the straightforward implementation based on saving the sum of the squares of the numbers. Add a main and verify that after each step the results are correct: public static void main ( String [] args ) { Accumulator acc = new Accumulator (); System . out . println ( acc . mean ()); // 0.0 System . out . println ( acc . var ()); // 0.0 System . out . println ( acc . stddev ()); // 0.0 acc . addDataValue ( 10 ); System . out . println ( acc . mean ()); // 10.0 System . out . println ( acc . var ()); // NaN System . out . println ( acc . stddev ()); // NaN acc . addDataValue ( 15 ); System . out . println ( acc . mean ()); // 12.5 System . out . println ( acc . var ()); // 12.5 System . out . println ( acc . stddev ()); // 3.5355339059327378 acc . addDataValue ( 20 ); System . out . println ( acc . mean ()); // 15 System . out . println ( acc . var ()); // 15 System . out . println ( acc . stddev ()); // 5 } 1.2.19 \u00b6 Parsing. Develop the parse constructors for your Date and Transaction implementations of Exercise 1.2.13 that take a single String argument to specify the initialization values, using the formats given in the table below. Partial solution: public Date ( String date ) { String [] fields = date . split ( \"/\" ); month = Integer . parseInt ( fields [ 0 ] ); day = Integer . parseInt ( fields [ 1 ] ); year = Integer . parseInt ( fields [ 2 ] ); } For simplicity: public class Transaction { String who ; Date when ; double amount ; public Transaction ( String transaction ) throws ParseException { String [] fields = transaction . split ( \"/\" ); who = fields [ 0 ] ; SimpleDateFormat format = new SimpleDateFormat ( \"dd-MM-yyyy\" ); when = format . parse ( fields [ 1 ] ); amount = Double . parseDouble ( fields [ 2 ] ); } }","title":"1.2   Data Abstraction"},{"location":"Chap01/1.2/#121","text":"Write a Point2D client that takes an integer value N from the command line, generates N random points in the unit square, and computes the distance separating the closest pair of points. Brute force approach: public class Ex121 { int N ; public static void main ( String [] args ) { int N = Integer . parseInt ( args [ 0 ] ); Point2D . Double [] points = new Point2D . Double [ N ] ; for ( int i = 0 ; i < N ; i += 1 ) { double x = ThreadLocalRandom . current (). nextDouble ( 0 , 400 ); double y = ThreadLocalRandom . current (). nextDouble ( 0 , 400 ); points [ i ] = new Point2D . Double ( x , y ); } System . out . println ( findClosestPairsBruteForce ( points )); } static double dist ( Point2D p1 , Point2D p2 ) { return Math . sqrt (( p1 . getX () - p2 . getY ()) * ( p1 . getX () - p2 . getX ()) + ( p1 . getY () - p2 . getY ()) * ( p1 . getY () - p2 . getY ()) ); } static double findClosestPairsBruteForce ( Point2D [] points ) { double min = Double . MAX_VALUE ; for ( int i = 0 ; i < points . length ; i += 1 ) for ( int j = i + 1 ; j < points . length ; j += 1 ) if ( dist ( points [ i ] , points [ j ] ) < min ) min = dist ( points [ i ] , points [ j ] ); return min ; } }","title":"1.2.1"},{"location":"Chap01/1.2/#122","text":"Write an Interval1D client that takes an int value N as command-line argument, reads N intervals (each defined by a pair of double values) from standard input, and prints all pairs that intersect. TODO","title":"1.2.2"},{"location":"Chap01/1.2/#123","text":"Write an Interval2D client that takes command-line arguments N, min, and max and generates N random 2D intervals whose width and height are uniformly distributed between min and max in the unit square. Draw them on StdDraw and print the number of pairs of intervals that intersect and the number of intervals that are contained in one another. TODO","title":"1.2.3"},{"location":"Chap01/1.2/#126","text":"A string s is a circular rotation of a string t if it matches when the characters are circularly shifted by any number of positions; e.g., ACTGACG is a circular shift of TGACGAC, and vice versa. Detecting this condition is important in the study of genomic sequences. Write a program that checks whether two given strings s and t are circular shifts of one another. Hint : The solution is a one-liner with indexOf(), length(), and string concatenation. Solution is based from this article : static boolean isCircular ( String a , String b ) { boolean result = false ; if ( a == null || b == null ) { return false ; } if ( a . length () != b . length ()) { return false ; } String combined = a + a ; if ( combined . indexOf ( b ) >= 0 ) { result = true ; } return result ; }","title":"1.2.6"},{"location":"Chap01/1.2/#127","text":"What does the following recursive function return? public static String mystery ( String s ){ int N = s . length (); if ( N <= 1 ) return s ; String a = s . substring ( 0 , N / 2 ); String b = s . substring ( N / 2 , N ); return mystery ( b ) + mystery ( a ); } It reverses the provided string. For example ABCDEFG becomes GFEDCBA .","title":"1.2.7"},{"location":"Chap01/1.2/#129","text":"Instrument BinarySearch (page 47) to use a Counter to count the total number of keys examined during all searches and then print the total after all searches are complete. Hint : Create a Counter in main() and pass it as an argument to rank(). public static int rank ( int key , int [] a , Counter c ) { return rank ( key , a , 0 , a . length - 1 , c ); } public static int rank ( int key , int [] a , int lo , int hi , Counter c ) { if ( lo > hi ) return - 1 ; int mid = lo + ( hi - lo ) / 2 ; if ( key < a [ mid ] ) { c . increment (); return rank ( key , a , lo , mid - 1 , c ); } else if ( key > a [ mid ] ) { c . increment (); return rank ( key , a , mid + 1 , hi , c ); } else return mid ; }","title":"1.2.9"},{"location":"Chap01/1.2/#1210","text":"Develop a class VisualCounter that allows both increment and decrement operations. Take two arguments N and max in the constructor, where N specifies the maximum number of operations and max specifies the maximum absolute value for the counter. As a side effect, create a plot showing the value of the counter each time its tally changes. static class VisualCounter { private final String name ; // counter name private int count = 0 ; // current value private int N = 0 ; // maximum number of operations private int max = 0 ; // maximum absolute value for the counter private int opCount = 0 ; // current operations count public VisualCounter ( String id , int N , int max ) { name = id ; this . N = N ; this . max = max ; } public void increment () { if ( opCount < N && count < max ) { count ++ ; opCount += 1 ; } } public void decrement () { opCount += 1 ; count -- ; } public int tally () { return count ; } public String toString () { return count + \" \" + name ; } }","title":"1.2.10"},{"location":"Chap01/1.2/#1211","text":"Develop an implementation SmartDate of our Date API that raises an exception if the date is not legal. We just add a simple validation for invalid day/year/month combinations public class SmartDate { private final int month ; private final int day ; private final int year ; public SmartDate ( int m , int d , int y ) throws IllegalArgumentException { validateDate ( m , d , y ); month = m ; day = d ; year = y ; } public int month () { return month ; } public int day () { return day ; } public int year () { return year ; } public String toString () { return month () + \"/\" + day () + \"/\" + year (); } boolean isLeapYear ( int year ) { return year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ); } public boolean equals ( Object x ) { if ( this == x ) return true ; if ( x == null ) return false ; if ( this . getClass () != x . getClass ()) return false ; Date that = ( Date ) x ; if ( this . day != that . day ) return false ; if ( this . month != that . month ) return false ; if ( this . year != that . year ) return false ; return true ; } private void validateDate ( int m , int d , int y ) throws IllegalArgumentException { if ( m > 12 || m < 1 ) { throw new IllegalArgumentException ( \"Invalid Month\" ); } if ( d > 31 || d < 1 ) { throw new IllegalArgumentException ( \"Invalid Day\" ); } if ( isLeapYear ( y ) && m == 2 && d > 29 ) { throw new IllegalArgumentException ( \"Invalid Day\" ); } } }","title":"1.2.11"},{"location":"Chap01/1.2/#1212","text":"Add a method dayOfTheWeek() to SmartDate that returns a String value Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, or Sunday, giving the appropriate day of the week for the date. You may assume that the date is in the 21st century A nice hack: public static String getDay ( int day , int month , int year ) { String dayOfWeek = null ; String [] days = { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" }; String date = String . valueOf ( day ) + \"/\" + String . valueOf ( month ) + \"/\" + String . valueOf ( year ); try { SimpleDateFormat format1 = new SimpleDateFormat ( \"d/M/yyyy\" ); Date dt1 = format1 . parse ( date ); dayOfWeek = days [ dt1 . getDay () - 1 ] ; } catch ( Exception e ) { System . out . println ( e ); } return dayOfWeek ; }","title":"1.2.12"},{"location":"Chap01/1.2/#1213","text":"Using our implementation of Date as a model (page 91), develop an implementation of Transaction. class Transaction implements Comparable < Transaction > { String who ; Date when ; double amount ; Transaction ( String who , Date when , double amount ) { this . who = who ; this . when = when ; this . amount = amount ; } String who () { return who ; } Date when () { return when ; } double getAmount () { return amount ; } @Override public String toString () { StringBuilder s = new StringBuilder (); s . append ( \"<Transaction \" ); s . append ( \"who=\" + who ); s . append ( \" when=\" + when ); s . append ( \" amount=\" + amount ); s . append ( \">\" ); return s . toString (); } @Override public boolean equals ( Object that ) { // If the object is compared with itself then return true if ( that == this ) { return true ; } if ( ! ( that instanceof Transaction )) { return false ; } Transaction t = ( Transaction ) that ; // Compare the data members and return accordingly return Double . compare ( amount , t . getAmount ()) == 0 && t . who == who && when == t . when ; } @Override public int hashCode () { int result = 17 ; result = 31 * result + ( int ) amount ; result = 31 * result + when . hashCode (); result = 31 * result + who . hashCode (); return result ; } @Override public int compareTo ( Transaction that ) { if ( when . compareTo ( that . when ) < 0 ) return - 1 ; if ( when . compareTo ( that . when ) > 0 ) { return 1 ; } // Transaction is identical: compare amount and who if ( this . amount < that . amount ) { return - 1 ; } else if ( this . amount > that . amount ) { return 1 ; } else { return who . compareTo ( that . who ); } } }","title":"1.2.13"},{"location":"Chap01/1.2/#1214","text":"Using our implementation of equals() in Date as a model (page 103), develop implementations of equals() for Transaction. Done in 1.2.23","title":"1.2.14"},{"location":"Chap01/1.2/#1216","text":"Rational numbers. Implement an immutable data type Rational for rational numbers that supports addition, subtraction, multiplication, and division. public class Rational Rational ( int numerator . int denominator ) Rational plus ( Rational b ) sum of this number and b Rational minus ( Rational b ) difference of this number and b Rational times ( Rational b ) product of this number and b Rational divides ( Rational b ) quotient of this number and b boolean equals ( Rational that ) is this number equal to that ? String toString () string representation You do not have to worry about testing for overflow (see Exercise 1.2.17), but use as instance variables two long values that represent the numerator and denominator to limit the possibility of overflow. Use Euclid\u2019s algorithm (see page 4) to ensure that the numerator and denominator never have any common factors. Include a test client that exercises all of your methods. static class Rational { int numerator ; int denominator ; Rational ( int numerator , int denominator ) { this . numerator = numerator ; this . denominator = denominator ; } Rational plus ( Rational b ) { if ( denominator == b . denominator ) { return new Rational ( numerator + b . numerator , denominator ); } int lcmNumber = lcm ( denominator , b . denominator ); int timesFirst = lcmNumber / denominator ; int timesSecond = lcmNumber / b . denominator ; return new Rational (( timesFirst * numerator ) + ( timesSecond * b . numerator ), lcmNumber ); } Rational minus ( Rational b ) { if ( denominator == b . denominator ) { return new Rational ( numerator - b . numerator , denominator ); } int lcmNumber = lcm ( denominator , b . denominator ); int timesFirst = lcmNumber / denominator ; int timesSecond = lcmNumber / b . denominator ; return new Rational (( timesFirst * numerator ) - ( timesSecond * b . numerator ), lcmNumber ); } public boolean equals ( Rational that ) { return denominator == that . denominator && numerator == that . numerator ; } Rational times ( Rational b ) { int newNuminator = numerator * b . numerator ; int newDenuminator = denominator * b . denominator ; return new Rational ( newNuminator , newDenuminator ); } Rational divides ( Rational b ) { Rational reciprocal = new Rational ( b . denominator , b . numerator ); // Ignore simplification step... return times ( reciprocal ); } @Override public String toString () { return \"Rational{\" + \"numerator=\" + numerator + \", denominator=\" + denominator + '}' ; }","title":"1.2.16"},{"location":"Chap01/1.2/#1217","text":"Robust implementation of rational numbers. Use assertions to develop an implementation of Rational (see Exercise 1.2.16) that is immune to overflow. TODO","title":"1.2.17"},{"location":"Chap01/1.2/#1218","text":"Variance for accumulator. Validate that the following code, which adds the methods var() and stddev() to Accumulator, computes both the mean and variance of the numbers presented as arguments to addDataValue(): public class Accumulator { private double m ; private double s ; private int N ; public void addDataValue ( double x ) { N ++ ; s = s + 1.0 * ( N - 1 ) / N * ( x - m ) * ( x - m ); m = m + ( x - m ) / N ; } public double mean () { return m ; } public double var () { return s / ( N - 1 ); } public double stddev () { return Math . sqrt ( this . var ()); } } This implementation is less susceptible to roundoff error than the straightforward implementation based on saving the sum of the squares of the numbers. Add a main and verify that after each step the results are correct: public static void main ( String [] args ) { Accumulator acc = new Accumulator (); System . out . println ( acc . mean ()); // 0.0 System . out . println ( acc . var ()); // 0.0 System . out . println ( acc . stddev ()); // 0.0 acc . addDataValue ( 10 ); System . out . println ( acc . mean ()); // 10.0 System . out . println ( acc . var ()); // NaN System . out . println ( acc . stddev ()); // NaN acc . addDataValue ( 15 ); System . out . println ( acc . mean ()); // 12.5 System . out . println ( acc . var ()); // 12.5 System . out . println ( acc . stddev ()); // 3.5355339059327378 acc . addDataValue ( 20 ); System . out . println ( acc . mean ()); // 15 System . out . println ( acc . var ()); // 15 System . out . println ( acc . stddev ()); // 5 }","title":"1.2.18"},{"location":"Chap01/1.2/#1219","text":"Parsing. Develop the parse constructors for your Date and Transaction implementations of Exercise 1.2.13 that take a single String argument to specify the initialization values, using the formats given in the table below. Partial solution: public Date ( String date ) { String [] fields = date . split ( \"/\" ); month = Integer . parseInt ( fields [ 0 ] ); day = Integer . parseInt ( fields [ 1 ] ); year = Integer . parseInt ( fields [ 2 ] ); } For simplicity: public class Transaction { String who ; Date when ; double amount ; public Transaction ( String transaction ) throws ParseException { String [] fields = transaction . split ( \"/\" ); who = fields [ 0 ] ; SimpleDateFormat format = new SimpleDateFormat ( \"dd-MM-yyyy\" ); when = format . parse ( fields [ 1 ] ); amount = Double . parseDouble ( fields [ 2 ] ); } }","title":"1.2.19"},{"location":"Chap01/1.3/","text":"1.3.1 \u00b6 Add a method isFull() to FixedCapacityStackOfStrings. public boolean isFull () { return N == a . length ; } 1.3.2 \u00b6 Give the output printed by java Stack for the input it was - the best - of times - - - it was - the - - Answer is: to be not that or be (2 left on stack) 1.3.3 \u00b6 Suppose that a client performs an intermixed sequence of (stack) push and pop operations. The push operations put the integers 0 through 9 in order onto the stack; the pop operations print out the return values. Which of the following sequence(s) could not occur? a. 4 3 2 1 0 9 8 7 6 5 b. 4 6 8 7 5 3 2 9 0 1 c. 2 5 6 7 4 8 9 3 1 0 d. 4 3 2 1 0 5 6 7 8 9 e. 1 2 3 4 5 6 9 8 7 0 f. 0 4 6 5 3 8 1 7 2 9 g. 1 4 7 9 8 6 5 3 0 2 h. 2 1 4 3 6 5 8 7 9 0 TODO 1.3.4 \u00b6 Write a stack client Parentheses that reads in a text stream from standard input and uses a stack to determine whether its parentheses are properly balanced. For example, your program should print true for [()]{}{ ()() } and false for [(]). static boolean areBalanced ( String expr ) { Stack < Character > stack = new Stack < Character > (); // Traversing the Expression for ( int i = 0 ; i < expr . length (); i ++ ) { char x = expr . charAt ( i ); if ( x == '(' || x == '[' || x == '{' ) { // Push the element in the stack stack . push ( x ); continue ; } if ( stack . isEmpty ()) return false ; switch ( x ) { case ')' : stack . pop (); if ( x != '(' ) return false ; break ; case '}' : stack . pop (); if ( x != '{' ) return false ; break ; case ']' : stack . pop (); if ( x != '[' ) return false ; break ; } } return ( stack . isEmpty ()); } 1.3.6 \u00b6 What does the following code fragment do to the queue q? Stack < String > stack = new Stack < String > (); while ( ! q . isEmpty ()) stack . push ( q . dequeue ()); while ( ! stack . isEmpty ()) q . enqueue ( stack . pop ()); TODO 1.3.7 \u00b6 Add a method peek() to Stack that returns the most recently inserted item on the stack (without popping it). TODO 1.3.8 \u00b6 Give the contents and size of the array for DoublingStackOfStrings with the input it was - the best - of times - - - it was - the - - TODO 1.3.9 \u00b6 Write a program that takes from standard input an expression without left parentheses and prints the equivalent infix expression with the parentheses inserted. For example, given the input: 1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) ) your program should print ( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) TODO 1.3.10 \u00b6 Write a filter InfixToPostfix that converts an arithmetic expression from infix to postfix. TODO 1.3.11 \u00b6 Write a program EvaluatePostfix that takes a postfix expression from standard input, evaluates it, and prints the value. (Piping the output of your program from the previous exercise to this program gives equivalent behavior to Evaluate. TODO 1.3.12 \u00b6 Write an iterable Stack client that has a static method copy() that takes a stack of strings as argument and returns a copy of the stack. Note : This ability is a prime example of the value of having an iterator, because it allows development of such functionality without changing the basic API. TODO 1.3.13 \u00b6 Suppose that a client performs an intermixed sequence of (queue) enqueue and dequeue operations. The enqueue operations put the integers 0 through 9 in order onto the queue; the dequeue operations print out the return value. Which of the following sequence(s) could not occur? a. 0 1 2 3 4 5 6 7 8 9 b. 4 6 8 7 5 3 2 9 0 1 c. 2 5 6 7 4 8 9 3 1 0 d. 4 3 2 1 0 5 6 7 8 9 TODO 1.3.14 \u00b6 Develop a class ResizingArrayQueueOfStrings that implements the queue abstraction with a fixed-size array, and then extend your implementation to use array resizing to remove the size restriction. TODO 1.3.15 \u00b6 Write a Queue client that takes a command-line argument k and prints the kth from the last string found on standard input (assuming that standard input has k or more strings). TODO 1.3.16 \u00b6 Using readInts() on page 126 as a model, write a static method readDates() for Date that reads dates from standard input in the format specified in the table on page 119 and returns an array containing them. TODO 1.3.17 \u00b6 Do Exercise 1.3.16 for Transaction. TODO 1.3.19 \u00b6 Give a code fragment that removes the last node in a linked list whose first node is first. TODO 1.3.20 \u00b6 Write a method delete() that takes an int argument k and deletes the kth element in a linked list, if it exists. TODO 1.3.21 \u00b6 Write a method find() that takes a linked list and a string key as arguments and returns true if some node in the list has key as its item field, false otherwise. TODO 1.3.24 \u00b6 Write a method removeAfter() that takes a linked-list Node as argument and removes the node following the given one (and does nothing if the argument or the next field in the argument node is null). TODO 1.3.25 \u00b6 Write a method insertAfter() that takes two linked-list Node arguments and inserts the second after the first on its list (and does nothing if either argument is null). TODO 1.3.26 \u00b6 Write a method remove() that takes a linked list and a string key as arguments and removes all of the nodes in the list that have key as its item field. TODO 1.3.27 \u00b6 Write a method max() that takes a reference to the first node in a linked list as argument and returns the value of the maximum key in the list. Assume that all keys are positive integers, and return 0 if the list is empty. TODO 1.3.28 \u00b6 Develop a recursive solution to the previous question. TODO 1.3.29 \u00b6 Write a Queue implementation that uses a circular linked list, which is the same as a linked list except that no links are null and the value of last.next is first whenever the list is not empty. Keep only one Node instance variable (last). TODO 1.3.31 \u00b6 Implement a nested class DoubleNode for building doubly-linked lists, where each node contains a reference to the item preceding it and the item following it in the list (null if there is no such item). Then implement static methods for the following tasks: insert at the beginning, insert at the end, remove from the beginning, remove from the end, insert before a given node, insert after a given node, and remove a given node. TODO 1.3.32 \u00b6 Steque. A stack-ended queue or steque is a data type that supports push, pop, and enqueue. Articulate an API for this ADT. Develop a linked-list-based implementation. TODO 1.3.33 \u00b6 Deque. A double-ended queue or deque (pronounced \u201cdeck\u201d) is like a stack or a queue but supports adding and removing items at both ends. A deque stores a collection of items and supports the following API: public class Deque < Item > implements Iterable < Item > Deque () create an empty deque boolean isEmpty () is the deque empty ? int size () number of items in the deque void pushLeft ( Item item ) add an item to the left end void pushRight ( Item item ) add an item to the right end Item popLeft () remove an item from the left end Item popRight () remove an item from the right end API for a generic double - ended queue Write a class Deque that uses a doubly-linked list to implement this API and a class ResizingArrayDeque that uses a resizing array. TODO 1.3.34 \u00b6 Random bag. A random bag stores a collection of items and supports the following API: public class RandomBag < Item > implements Iterable < Item > RandomBag () create an empty random bag boolean isEmpty () is the bag empty ? int size () number of items in the bag void add ( Item item ) add an item Write a class RandomBag that implements this API. Note that this API is the same as for Bag, except for the adjective random, which indicates that the iteration should provide the items in random order (all N ! permutations equally likely, for each iterator). Hint : Put the items in an array and randomize their order in the iterator\u2019s constructor. TODO 1.3.35 \u00b6 Random queue. A random queue stores a collection of items and supports the following API: public class RandomQueue < Item > RandomQueue () create an empty random queue boolean isEmpty () is the queue empty ? void enqueue ( Item item ) add an item Item dequeue () remove and return a random item ( sample without replacement ) Item sample () return a random item , but do not remove ( sample with replacement ) Write a class RandomQueue that implements this API. Hint : Use an array representation (with resizing). To remove an item, swap one at a random position (indexed 0 through N-1) with the one at the last position (index N-1). Then delete and return the last object, as in ResizingArrayStack. Write a client that deals bridge hands (13 cards each) using RandomQueue . TODO 1.3.36 \u00b6 Random iterator. Write an iterator for RandomQueue from the previous exercise that returns the items in random order. TODO 1.3.37 \u00b6 Josephus problem. In the Josephus problem from antiquity, N people are in dire straits and agree to the following strategy to reduce the population. They arrange themselves in a circle (at positions numbered from 0 to N\u20131) and proceed around the circle, eliminating every Mth person until only one person is left. Legend has it that Josephus figured out where to sit to avoid being eliminated. Write a Queue client Josephus that takes N and M from the command line and prints out the order in which people are eliminated (and thus would show Josephus where to sit in the circle). % java Josephus 7 2 1 3 5 0 4 2 6 TODO 1.3.38 \u00b6 Delete kth element. Implement a class that supports the following API: public class GeneralizedQueue < Item > GeneralizedQueue () create an empty queue boolean isEmpty () is the queue empty ? void insert ( Item x ) add an item Item delete ( int k ) delete and return the kth least recently inserted item First, develop an implementation that uses an array implementation, and then develop one that uses a linked-list implementation. Note : the algorithms and data structures that we introduce in Chapter 3 make it possible to develop an implementation that can guarantee that both insert() and delete() take time prortional to the logarithm of the number of items in the queue\u2014see Exercise 3.5.27. TODO 1.3.39 \u00b6 Ring buffer. A ring buffer, or circular queue, is a FIFO data structure of a fixed size N. It is useful for transferring data between asynchronous processes or for storing log files. When the buffer is empty, the consumer waits until data is deposited; when the buffer is full, the producer waits to deposit data. Develop an API for a RingBuffer and an implementation that uses an array representation (with circular wrap-around). TODO 1.3.40 \u00b6 Move-to-front. Read in a sequence of characters from standard input and maintain the characters in a linked list with no duplicates. When you read in a previously unseen character, insert it at the front of the list. When you read in a duplicate character, delete it from the list and reinsert it at the beginning. Name your program MoveToFront: it implements the well-known move-to-front strategy, which is useful for caching, data compression, and many other applications where items that have been recently accessed are more likely to be reaccessed. TODO 1.3.41 \u00b6 Copy a queue. Create a new constructor so that Queue<Item> r = new Queue<Item>(q); makes r a reference to a new and independent copy of the queue q. You should be able to push and pop from either q or r without influencing the other. Hint : Delete all of the elements from q and add these elements to both q and r. TODO 1.3.42 \u00b6 Copy a stack. Create a new constructor for the linked-list implementation of Stack so that Stack<Item> t = new Stack<Item>(s); makes t a reference to a new and independent copy of the stack s. TODO 1.3.43 \u00b6 Listing files. A folder is a list of files and folders. Write a program that takes the name of a folder as a command-line argument and prints out all of the files contained in that folder, with the contents of each folder recursively listed (indented) under that folder\u2019s name. Hint : Use a queue, and see java.io.File. TODO 1.3.44 \u00b6 Text editor buffer. Develop a data type for a buffer in a text editor that implements the following API: public class Buffer Buffer () create an empty buffer void insert ( char c ) insert c at the cursor position char delete () delete and return the character at the cursor void left ( int k ) move the cursor k positions to the left void right ( int k ) move the cursor k positions to the right int size () number of characters in the buffer Hint : Use two stacks. TODO 1.3.46 \u00b6 Forbidden triple for stack generability. Prove that a permutation can be generated by a stack (as in the previous question) if and only if it has no forbidden triple (a, b, c) such that a < b < c with c first, a second, and b third (possibly with other intervening integers between c and a and between a and b). Partial solution: Suppose that there is a forbidden triple (a, b, c). Item c is popped before a and b, but a and b are pushed before c. Thus, when c is pushed, both a and b are on the stack. Therefore, a cannot be popped before b. TODO 1.3.47 \u00b6 Catenable queues, stacks, or steques. Add an extra operation catenation that (destructively) concatenates two queues, stacks, or steques (see Exercise 1.3.32). Hint : Use a circular linked list, maintaining a pointer to the last item. TODO 1.3.48 \u00b6 Two stacks with a deque. Implement two stacks with a single deque so that each operation takes a constant number of deque operations (see Exercise 1.3.33). TODO 1.3.49 \u00b6 Queue with three stacks. Implement a queue with three stacks so that each queue operation takes a constant (worst-case) number of stack operations. Warning : high degree of difficulty TODO","title":"1.3   Bags, Queues, and Stacks"},{"location":"Chap01/1.3/#131","text":"Add a method isFull() to FixedCapacityStackOfStrings. public boolean isFull () { return N == a . length ; }","title":"1.3.1"},{"location":"Chap01/1.3/#132","text":"Give the output printed by java Stack for the input it was - the best - of times - - - it was - the - - Answer is: to be not that or be (2 left on stack)","title":"1.3.2"},{"location":"Chap01/1.3/#133","text":"Suppose that a client performs an intermixed sequence of (stack) push and pop operations. The push operations put the integers 0 through 9 in order onto the stack; the pop operations print out the return values. Which of the following sequence(s) could not occur? a. 4 3 2 1 0 9 8 7 6 5 b. 4 6 8 7 5 3 2 9 0 1 c. 2 5 6 7 4 8 9 3 1 0 d. 4 3 2 1 0 5 6 7 8 9 e. 1 2 3 4 5 6 9 8 7 0 f. 0 4 6 5 3 8 1 7 2 9 g. 1 4 7 9 8 6 5 3 0 2 h. 2 1 4 3 6 5 8 7 9 0 TODO","title":"1.3.3"},{"location":"Chap01/1.3/#134","text":"Write a stack client Parentheses that reads in a text stream from standard input and uses a stack to determine whether its parentheses are properly balanced. For example, your program should print true for [()]{}{ ()() } and false for [(]). static boolean areBalanced ( String expr ) { Stack < Character > stack = new Stack < Character > (); // Traversing the Expression for ( int i = 0 ; i < expr . length (); i ++ ) { char x = expr . charAt ( i ); if ( x == '(' || x == '[' || x == '{' ) { // Push the element in the stack stack . push ( x ); continue ; } if ( stack . isEmpty ()) return false ; switch ( x ) { case ')' : stack . pop (); if ( x != '(' ) return false ; break ; case '}' : stack . pop (); if ( x != '{' ) return false ; break ; case ']' : stack . pop (); if ( x != '[' ) return false ; break ; } } return ( stack . isEmpty ()); }","title":"1.3.4"},{"location":"Chap01/1.3/#136","text":"What does the following code fragment do to the queue q? Stack < String > stack = new Stack < String > (); while ( ! q . isEmpty ()) stack . push ( q . dequeue ()); while ( ! stack . isEmpty ()) q . enqueue ( stack . pop ()); TODO","title":"1.3.6"},{"location":"Chap01/1.3/#137","text":"Add a method peek() to Stack that returns the most recently inserted item on the stack (without popping it). TODO","title":"1.3.7"},{"location":"Chap01/1.3/#138","text":"Give the contents and size of the array for DoublingStackOfStrings with the input it was - the best - of times - - - it was - the - - TODO","title":"1.3.8"},{"location":"Chap01/1.3/#139","text":"Write a program that takes from standard input an expression without left parentheses and prints the equivalent infix expression with the parentheses inserted. For example, given the input: 1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) ) your program should print ( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) TODO","title":"1.3.9"},{"location":"Chap01/1.3/#1310","text":"Write a filter InfixToPostfix that converts an arithmetic expression from infix to postfix. TODO","title":"1.3.10"},{"location":"Chap01/1.3/#1311","text":"Write a program EvaluatePostfix that takes a postfix expression from standard input, evaluates it, and prints the value. (Piping the output of your program from the previous exercise to this program gives equivalent behavior to Evaluate. TODO","title":"1.3.11"},{"location":"Chap01/1.3/#1312","text":"Write an iterable Stack client that has a static method copy() that takes a stack of strings as argument and returns a copy of the stack. Note : This ability is a prime example of the value of having an iterator, because it allows development of such functionality without changing the basic API. TODO","title":"1.3.12"},{"location":"Chap01/1.3/#1313","text":"Suppose that a client performs an intermixed sequence of (queue) enqueue and dequeue operations. The enqueue operations put the integers 0 through 9 in order onto the queue; the dequeue operations print out the return value. Which of the following sequence(s) could not occur? a. 0 1 2 3 4 5 6 7 8 9 b. 4 6 8 7 5 3 2 9 0 1 c. 2 5 6 7 4 8 9 3 1 0 d. 4 3 2 1 0 5 6 7 8 9 TODO","title":"1.3.13"},{"location":"Chap01/1.3/#1314","text":"Develop a class ResizingArrayQueueOfStrings that implements the queue abstraction with a fixed-size array, and then extend your implementation to use array resizing to remove the size restriction. TODO","title":"1.3.14"},{"location":"Chap01/1.3/#1315","text":"Write a Queue client that takes a command-line argument k and prints the kth from the last string found on standard input (assuming that standard input has k or more strings). TODO","title":"1.3.15"},{"location":"Chap01/1.3/#1316","text":"Using readInts() on page 126 as a model, write a static method readDates() for Date that reads dates from standard input in the format specified in the table on page 119 and returns an array containing them. TODO","title":"1.3.16"},{"location":"Chap01/1.3/#1317","text":"Do Exercise 1.3.16 for Transaction. TODO","title":"1.3.17"},{"location":"Chap01/1.3/#1319","text":"Give a code fragment that removes the last node in a linked list whose first node is first. TODO","title":"1.3.19"},{"location":"Chap01/1.3/#1320","text":"Write a method delete() that takes an int argument k and deletes the kth element in a linked list, if it exists. TODO","title":"1.3.20"},{"location":"Chap01/1.3/#1321","text":"Write a method find() that takes a linked list and a string key as arguments and returns true if some node in the list has key as its item field, false otherwise. TODO","title":"1.3.21"},{"location":"Chap01/1.3/#1324","text":"Write a method removeAfter() that takes a linked-list Node as argument and removes the node following the given one (and does nothing if the argument or the next field in the argument node is null). TODO","title":"1.3.24"},{"location":"Chap01/1.3/#1325","text":"Write a method insertAfter() that takes two linked-list Node arguments and inserts the second after the first on its list (and does nothing if either argument is null). TODO","title":"1.3.25"},{"location":"Chap01/1.3/#1326","text":"Write a method remove() that takes a linked list and a string key as arguments and removes all of the nodes in the list that have key as its item field. TODO","title":"1.3.26"},{"location":"Chap01/1.3/#1327","text":"Write a method max() that takes a reference to the first node in a linked list as argument and returns the value of the maximum key in the list. Assume that all keys are positive integers, and return 0 if the list is empty. TODO","title":"1.3.27"},{"location":"Chap01/1.3/#1328","text":"Develop a recursive solution to the previous question. TODO","title":"1.3.28"},{"location":"Chap01/1.3/#1329","text":"Write a Queue implementation that uses a circular linked list, which is the same as a linked list except that no links are null and the value of last.next is first whenever the list is not empty. Keep only one Node instance variable (last). TODO","title":"1.3.29"},{"location":"Chap01/1.3/#1331","text":"Implement a nested class DoubleNode for building doubly-linked lists, where each node contains a reference to the item preceding it and the item following it in the list (null if there is no such item). Then implement static methods for the following tasks: insert at the beginning, insert at the end, remove from the beginning, remove from the end, insert before a given node, insert after a given node, and remove a given node. TODO","title":"1.3.31"},{"location":"Chap01/1.3/#1332","text":"Steque. A stack-ended queue or steque is a data type that supports push, pop, and enqueue. Articulate an API for this ADT. Develop a linked-list-based implementation. TODO","title":"1.3.32"},{"location":"Chap01/1.3/#1333","text":"Deque. A double-ended queue or deque (pronounced \u201cdeck\u201d) is like a stack or a queue but supports adding and removing items at both ends. A deque stores a collection of items and supports the following API: public class Deque < Item > implements Iterable < Item > Deque () create an empty deque boolean isEmpty () is the deque empty ? int size () number of items in the deque void pushLeft ( Item item ) add an item to the left end void pushRight ( Item item ) add an item to the right end Item popLeft () remove an item from the left end Item popRight () remove an item from the right end API for a generic double - ended queue Write a class Deque that uses a doubly-linked list to implement this API and a class ResizingArrayDeque that uses a resizing array. TODO","title":"1.3.33"},{"location":"Chap01/1.3/#1334","text":"Random bag. A random bag stores a collection of items and supports the following API: public class RandomBag < Item > implements Iterable < Item > RandomBag () create an empty random bag boolean isEmpty () is the bag empty ? int size () number of items in the bag void add ( Item item ) add an item Write a class RandomBag that implements this API. Note that this API is the same as for Bag, except for the adjective random, which indicates that the iteration should provide the items in random order (all N ! permutations equally likely, for each iterator). Hint : Put the items in an array and randomize their order in the iterator\u2019s constructor. TODO","title":"1.3.34"},{"location":"Chap01/1.3/#1335","text":"Random queue. A random queue stores a collection of items and supports the following API: public class RandomQueue < Item > RandomQueue () create an empty random queue boolean isEmpty () is the queue empty ? void enqueue ( Item item ) add an item Item dequeue () remove and return a random item ( sample without replacement ) Item sample () return a random item , but do not remove ( sample with replacement ) Write a class RandomQueue that implements this API. Hint : Use an array representation (with resizing). To remove an item, swap one at a random position (indexed 0 through N-1) with the one at the last position (index N-1). Then delete and return the last object, as in ResizingArrayStack. Write a client that deals bridge hands (13 cards each) using RandomQueue . TODO","title":"1.3.35"},{"location":"Chap01/1.3/#1336","text":"Random iterator. Write an iterator for RandomQueue from the previous exercise that returns the items in random order. TODO","title":"1.3.36"},{"location":"Chap01/1.3/#1337","text":"Josephus problem. In the Josephus problem from antiquity, N people are in dire straits and agree to the following strategy to reduce the population. They arrange themselves in a circle (at positions numbered from 0 to N\u20131) and proceed around the circle, eliminating every Mth person until only one person is left. Legend has it that Josephus figured out where to sit to avoid being eliminated. Write a Queue client Josephus that takes N and M from the command line and prints out the order in which people are eliminated (and thus would show Josephus where to sit in the circle). % java Josephus 7 2 1 3 5 0 4 2 6 TODO","title":"1.3.37"},{"location":"Chap01/1.3/#1338","text":"Delete kth element. Implement a class that supports the following API: public class GeneralizedQueue < Item > GeneralizedQueue () create an empty queue boolean isEmpty () is the queue empty ? void insert ( Item x ) add an item Item delete ( int k ) delete and return the kth least recently inserted item First, develop an implementation that uses an array implementation, and then develop one that uses a linked-list implementation. Note : the algorithms and data structures that we introduce in Chapter 3 make it possible to develop an implementation that can guarantee that both insert() and delete() take time prortional to the logarithm of the number of items in the queue\u2014see Exercise 3.5.27. TODO","title":"1.3.38"},{"location":"Chap01/1.3/#1339","text":"Ring buffer. A ring buffer, or circular queue, is a FIFO data structure of a fixed size N. It is useful for transferring data between asynchronous processes or for storing log files. When the buffer is empty, the consumer waits until data is deposited; when the buffer is full, the producer waits to deposit data. Develop an API for a RingBuffer and an implementation that uses an array representation (with circular wrap-around). TODO","title":"1.3.39"},{"location":"Chap01/1.3/#1340","text":"Move-to-front. Read in a sequence of characters from standard input and maintain the characters in a linked list with no duplicates. When you read in a previously unseen character, insert it at the front of the list. When you read in a duplicate character, delete it from the list and reinsert it at the beginning. Name your program MoveToFront: it implements the well-known move-to-front strategy, which is useful for caching, data compression, and many other applications where items that have been recently accessed are more likely to be reaccessed. TODO","title":"1.3.40"},{"location":"Chap01/1.3/#1341","text":"Copy a queue. Create a new constructor so that Queue<Item> r = new Queue<Item>(q); makes r a reference to a new and independent copy of the queue q. You should be able to push and pop from either q or r without influencing the other. Hint : Delete all of the elements from q and add these elements to both q and r. TODO","title":"1.3.41"},{"location":"Chap01/1.3/#1342","text":"Copy a stack. Create a new constructor for the linked-list implementation of Stack so that Stack<Item> t = new Stack<Item>(s); makes t a reference to a new and independent copy of the stack s. TODO","title":"1.3.42"},{"location":"Chap01/1.3/#1343","text":"Listing files. A folder is a list of files and folders. Write a program that takes the name of a folder as a command-line argument and prints out all of the files contained in that folder, with the contents of each folder recursively listed (indented) under that folder\u2019s name. Hint : Use a queue, and see java.io.File. TODO","title":"1.3.43"},{"location":"Chap01/1.3/#1344","text":"Text editor buffer. Develop a data type for a buffer in a text editor that implements the following API: public class Buffer Buffer () create an empty buffer void insert ( char c ) insert c at the cursor position char delete () delete and return the character at the cursor void left ( int k ) move the cursor k positions to the left void right ( int k ) move the cursor k positions to the right int size () number of characters in the buffer Hint : Use two stacks. TODO","title":"1.3.44"},{"location":"Chap01/1.3/#1346","text":"Forbidden triple for stack generability. Prove that a permutation can be generated by a stack (as in the previous question) if and only if it has no forbidden triple (a, b, c) such that a < b < c with c first, a second, and b third (possibly with other intervening integers between c and a and between a and b). Partial solution: Suppose that there is a forbidden triple (a, b, c). Item c is popped before a and b, but a and b are pushed before c. Thus, when c is pushed, both a and b are on the stack. Therefore, a cannot be popped before b. TODO","title":"1.3.46"},{"location":"Chap01/1.3/#1347","text":"Catenable queues, stacks, or steques. Add an extra operation catenation that (destructively) concatenates two queues, stacks, or steques (see Exercise 1.3.32). Hint : Use a circular linked list, maintaining a pointer to the last item. TODO","title":"1.3.47"},{"location":"Chap01/1.3/#1348","text":"Two stacks with a deque. Implement two stacks with a single deque so that each operation takes a constant number of deque operations (see Exercise 1.3.33). TODO","title":"1.3.48"},{"location":"Chap01/1.3/#1349","text":"Queue with three stacks. Implement a queue with three stacks so that each queue operation takes a constant (worst-case) number of stack operations. Warning : high degree of difficulty TODO","title":"1.3.49"},{"location":"Chap01/1.4/","text":"","title":"1.4   Analysis of Algorithms"},{"location":"Chap01/1.5/","text":"","title":"1.5   Case Study - Union-Find"}]}