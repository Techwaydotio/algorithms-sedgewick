## 1.2.1 
> Write a Point2D client that takes an integer value N from the command line,
generates N random points in the unit square, and computes the distance separating
the closest pair of points.

Brute force approach:

```java
public class Ex121 {
    int N;

    public static void main(String[] args) {
        int N = Integer.parseInt(args[0]);
        Point2D.Double[] points = new Point2D.Double[N];
        for (int i = 0; i < N; i += 1) {
            double x = ThreadLocalRandom.current().nextDouble(0, 400);
            double y = ThreadLocalRandom.current().nextDouble(0, 400);
            points[i] = new Point2D.Double(x, y);
        }

        System.out.println(findClosestPairsBruteForce(points));
    }

    static double dist(Point2D p1, Point2D p2) {
        return Math.sqrt((p1.getX() - p2.getY()) * (p1.getX() - p2.getX()) +
                (p1.getY() - p2.getY()) * (p1.getY() - p2.getY())
        );
    }

    static double findClosestPairsBruteForce(Point2D[] points) {
        double min = Double.MAX_VALUE;
        for (int i = 0; i < points.length; i += 1)
            for (int j = i + 1; j < points.length; j += 1)
                if (dist(points[i], points[j]) < min)
                    min = dist(points[i], points[j]);
        return min;
    }
}
```

## 1.2.2 
> Write an Interval1D client that takes an int value N as command-line argument, reads N intervals (each defined by a pair of double values) from standard input,
and prints all pairs that intersect.

**TODO**

## 1.2.3 

> Write an Interval2D client that takes command-line arguments N, min, and max
and generates N random 2D intervals whose width and height are uniformly distributed
between min and max in the unit square. Draw them on StdDraw and print the number
of pairs of intervals that intersect and the number of intervals that are contained in one
another.

**TODO**

## 1.2.6 
> A string s is a circular rotation of a string t if it matches when the characters
are circularly shifted by any number of positions; e.g., ACTGACG is a circular shift of
TGACGAC, and vice versa. Detecting this condition is important in the study of genomic
sequences. Write a program that checks whether two given strings s and t are circular
shifts of one another. Hint : The solution is a one-liner with indexOf(), length(), and
string concatenation.

Solution is based from [this article](https://javarevisited.blogspot.com/2017/07/2-ways-to-check-if-one-string-is-rotation-of-another-String.html
):


```java
static boolean isCircular(String a, String b) {
    boolean result = false;
    if (a == null || b == null) {
        return false;
    }
    if (a.length() != b.length()) {
        return false;
    }
    String combined = a + a;
    if (combined.indexOf(b) >= 0) {
        result = true;
    }
    return result;
}
```

## 1.2.7 
> What does the following recursive function return?

```java
public static String mystery(String s){
 int N = s.length();
 if (N <= 1) return s;
 String a = s.substring(0, N/2);
 String b = s.substring(N/2, N);
 return mystery(b) + mystery(a);
}
```

It reverses the provided string. For example `ABCDEFG` becomes `GFEDCBA`.

## 1.2.9
> Instrument BinarySearch (page 47) to use a Counter to count the total number
of keys examined during all searches and then print the total after all searches are complete. 
>Hint : Create a Counter in main() and pass it as an argument to rank().


```java
public static int rank(int key, int[] a, Counter c) {
    return rank(key, a, 0, a.length - 1, c);
}

public static int rank(int key, int[] a, int lo, int hi, Counter c) {
    if (lo > hi) return -1;
    int mid = lo + (hi - lo) / 2;
    if (key < a[mid]) {
        c.increment();
        return rank(key, a, lo, mid - 1, c);
    } else if (key > a[mid]) {
        c.increment();
        return rank(key, a, mid + 1, hi, c);
    } else return mid;
}
```

## 1.2.10 
> Develop a class VisualCounter that allows both increment and decrement
operations. Take two arguments N and max in the constructor, where N specifies the
maximum number of operations and max specifies the maximum absolute value for
the counter. As a side effect, create a plot showing the value of the counter each time its
tally changes.

**TODO**

## 1.2.11 
> Develop an implementation SmartDate of our Date API that raises an exception if the date is not legal.

**TODO**

## 1.2.12 
> Add a method dayOfTheWeek() to SmartDate that returns a String value
Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, or Sunday, giving the appropriate day of the week for the date. You may assume that the date is in the 21st
century

**TODO**

## 1.2.13 
> Using our implementation of Date as a model (page 91), develop an implementation of Transaction.

**TODO**

## 1.2.14 
> Using our implementation of equals() in Date as a model (page 103), develop
implementations of equals() for Transaction.

**TODO**


## 1.2.16 
> Rational numbers. Implement an immutable data type Rational for rational
numbers that supports addition, subtraction, multiplication, and division.
public class Rational

```java
Rational(int numerator. int denominator)
Rational plus(Rational b) sum of this number and b
Rational minus(Rational b) difference of this number and b
Rational times(Rational b) product of this number and b
Rational divides(Rational b) quotient of this number and b
boolean equals(Rational that) is this number equal to that ?
String toString() string representation
```
> You do not have to worry about testing for overflow (see Exercise 1.2.17), but use as
instance variables two long values that represent the numerator and denominator to
limit the possibility of overflow. Use Euclidâ€™s algorithm (see page 4) to ensure that the
numerator and denominator never have any common factors. Include a test client that
exercises all of your methods.


## 1.2.17 
> Robust implementation of rational numbers. Use assertions to develop an implementation of 
Rational (see Exercise 1.2.16) that is immune to overflow.

## 1.2.18 
> Variance for accumulator. Validate that the following code, which adds the
methods var() and stddev() to Accumulator, computes both the mean and variance
of the numbers presented as arguments to addDataValue():

```java
public class Accumulator
{
 private double m;
 private double s;
 private int N;
 public void addDataValue(double x)
 {
 N++;
 s = s + 1.0 * (N-1) / N * (x - m) * (x - m);
 m = m + (x - m) / N;
 }
 public double mean()
 { return m; }
 public double var()
 { return s/(N - 1); }
 public double stddev()
 { return Math.sqrt(this.var()); }
}
```

> This implementation is less susceptible to roundoff error 
than the straightforward implementation based on saving the sum of the squares of the numbers.


## 1.2.19 
> Parsing. Develop the parse constructors for your Date and Transaction implementations of Exercise 1.2.13 that take a single String argument to specify the
initialization values, using the formats given in the table below.
Partial solution:

```java
public Date(String date)
{
 String[] fields = date.split("/");
 month = Integer.parseInt(fields[0]);
 day = Integer.parseInt(fields[1]);
 year = Integer.parseInt(fields[2]);
}
```
