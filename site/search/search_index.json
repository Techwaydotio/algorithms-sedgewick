{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solutions to Algorithms Forth Edition \u00b6 Getting Started \u00b6 This website contains nearly complete solutions to the textbook - Algorithms, 4th Edition , published by Robert Sedgewick and Kevin Wayne. I hope to organize solutions to help people and myself study algorithms. By using Markdown (.md) files, this page is much more readable on portable devices. How I Generate the Website? \u00b6 I use the static site generator MkDocs and the theme Material to build this website. We use KaTeX for rendering math expressions, which is fast and beautiful. License \u00b6 Licensed under the CC0 1.0 Universal (CC0 1.0) .","title":"Preface"},{"location":"#solutions-to-algorithms-forth-edition","text":"","title":"Solutions to Algorithms Forth Edition"},{"location":"#getting-started","text":"This website contains nearly complete solutions to the textbook - Algorithms, 4th Edition , published by Robert Sedgewick and Kevin Wayne. I hope to organize solutions to help people and myself study algorithms. By using Markdown (.md) files, this page is much more readable on portable devices.","title":"Getting Started"},{"location":"#how-i-generate-the-website","text":"I use the static site generator MkDocs and the theme Material to build this website. We use KaTeX for rendering math expressions, which is fast and beautiful.","title":"How I Generate the Website?"},{"location":"#license","text":"Licensed under the CC0 1.0 Universal (CC0 1.0) .","title":"License"},{"location":"Chap01/1.1/","text":"1.1.1 \u00b6 Give the value of each of the following expressions: a. ( 0 + 15 ) / 2 b. 2.0e-6 * 100000000.1 c. true && false || true && true a. jshell> (0 + 15) / 2 $1 ==> 7 b. jshell> 2.0e-6 * 100000000.1 $2 ==> 200.0000002 c. jshell> true && false || true && true $3 ==> true 1.1.2 \u00b6 Give the type and value of each of the following expressions: a. (1 + 2.236)/2 b. 1 + 2 + 3 + 4.0 c. 4.1 >= 4 d. 1 + 2 + \"3\" a. jshell> (1 + 2.236)/2 $1 ==> 1.618 jshell> ((Object)1.618).getClass().getName() $2 ==> \"java.lang.Double\" b. jshell> 1 + 2 + 3 + 4.0 $3 ==> 10.0 // Double c. jshell> 4.1 >= 4 $4 ==> true // Boolean d. jshell> 1 + 2 + \"3\" $5 ==> \"33\" 1.1.3 \u00b6 Write a program that takes three integer command-line arguments and prints equal if all three are equal, and not equal otherwise. public static void main ( String [] args ) { int first = Integer . parseInt ( args [ 0 ] ); int second = Integer . parseInt ( args [ 1 ] ); int third = Integer . parseInt ( args [ 2 ] ); if ( first == second && second == third ) { System . out . println ( \"equal\" ); } else { System . out . println ( \"not equal\" ); } } 1.1.4 \u00b6 What (if anything) is wrong with each of the following statements? a. if (a > b) then c = 0; b. if a > b { c = 0; } c. if (a > b) c = 0; d. if (a > b) c = 0 else b = 0; a. The programs does not compile. | Error: | variable declaration not allowed here | if (a > b) then c = 0; | ^---------^ b. The program fails to compile. | Error: | '(' expected | if a > b { c = 0; } | ^ | Error: | ')' expected | if a > b { c = 0; } | ^ c. The problem compiles. d. The problem does not compile. It's missing a semicolon; jshell> if (a > b) c = 0 else b = 0; | Error: | ';' expected | if (a > b) c = 0 else b = 0; | 1.1.5 \u00b6 Write a code fragment that prints true if the double variables x and y are both strictly between 0 and 1 and false otherwise. static boolean areBetween0and1 ( double x , double y ) { return isBetween0and1 ( x ) && isBetween0and1 ( y ); } static boolean isBetween0and1 ( double x ) { if ( x > 0 && x < 1 ) { return true ; } return false ; } 1.1.6 \u00b6 What does the following program print? int f = 0 ; int g = 1 ; for ( int i = 0 ; i <= 15 ; i ++ ) { StdOut . println ( f ); f = f + g ; g = f - g ; } It prints: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 1.1.7 \u00b6 Give the value printed by each of the following code fragments: a . double t = 9.0 ; while ( Math . abs ( t - 9.0 / t ) > .001 ) t = ( 9.0 / t + t ) / 2.0 ; StdOut . printf ( \"%.5f\\n\" , t ); b . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); c . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i *= 2 ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); a) 3.00009 b) 499500 c) 1023 1.1.8 \u00b6 What do each of the following print? a. System.out.println('b'); b. System.out.println('b' + 'c'); c. System.out.println((char) ('a' + 4)); Explain each outcome. a) It prints 'b' and a new line b) It prints 197. First 'b' is converted to int (98) and then 'c' to int (99) so the total is 98 + 99 = 197 c) It prints 'e'. First ('a' + 4) is converted to int. 'a' is 97 so result is 97 + 4 = 101. Then this int is converted to char which is 'e'; 1.1.11 \u00b6 Write a code fragment that prints the contents of a two-dimensional boolean array, using * to represent true and a space to represent false. Include row and column numbers. static void printContents ( boolean [][] arr ) { for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { if ( arr [ i ][ j ] ) { System . out . printf ( \"row: %d, column: %d = *\\n\" , i , j ); } else { System . out . printf ( \"row: %d, column: %d = \\n\" , i , j ); } } } } 1.1.12 \u00b6 What does the following code fragment print? int [] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = 9 - i ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = a [ a [ i ]] ; for ( int i = 0 ; i < 10 ; i ++ ) System . out . println ( i ); It prints: 0 1 2 3 4 5 6 7 8 9 1.1.13 \u00b6 Write a code fragment to print the transposition (rows and columns changed) of a two-dimensional array with M rows and N columns. static void printTranspose ( int [][] arr ) { int [][] result = new int [ arr [ 0 ] . length ][ arr . length ] ; for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { result [ j ][ i ] = arr [ i ][ j ] ; } } for ( int i = 0 ; i < result . length ; i += 1 ) { for ( int j = 0 ; j < result [ i ] . length ; j += 1 ) { System . out . printf ( \"row: %d, column: %d = %d\\n\" , i , j , result [ i ][ j ] ); } } } 1.1.14 \u00b6 Write a static method lg() that takes an int value N as argument and returns the largest int not larger than the base-2 logarithm of N. Do not use Math. static int lg ( int n ) { if ( n == 1 ) { return 0 ; } if ( n == 2 ) { return 1 ; } int acc = 2 ; int result = 1 ; while ( acc * 2 <= n ) { acc *= 2 ; result += 1 ; } return result ; } 1.1.15 \u00b6 Write a static method histogram() that takes an array a[] of int values and an integer M as arguments and returns an array of length M whose ith entry is the number of times the integer i appeared in the argument array. If the values in a[] are all between 0 and M\u20131, the sum of the values in the returned array should be equal to a.length. static int [] histogram ( int [] arr , int M ) { int [] result = new int [ M ] ; for ( int i : arr ) { if ( i < M ) { result [ i ] += 1 ; } } return result ; } 1.1.16 \u00b6 Give the value of exR1(6): public static String exR1 ( int n ) { if ( n <= 0 ) return \"\" ; return exR1 ( n - 3 ) + n + exR1 ( n - 2 ) + n ; } Result is 311361142246 1.1.18 \u00b6 Consider the following recursive function: public static int mystery ( int a , int b ) { if ( b == 0 ) return 0 ; if ( b % 2 == 0 ) return mystery ( a + a , b / 2 ); return mystery ( a + a , b / 2 ) + a ; } What are the values of mystery(2, 25) and mystery(3, 11)? Given positive integers a and b, describe what value mystery(a, b) computes. Answer the same question, but replace + with * and replace return 0 with return 1. mystery(2, 25) prints 2 * 25 = 50 mystery(3, 11) prints 3 * 11 = 33 mystery indeed computes $a * b$; If we replace + with * and 0 with 1 the fuction becomes: public static int mystery ( int a , int b ) { if ( b == 0 ) return 1 ; if ( b % 2 == 0 ) return mystery ( a * a , b / 2 ); return mystery ( a * a , b / 2 ) * a ; } This computes the value $a^b$. 1.1.19 \u00b6 Run the following program on your computer: public class Fibonacci { public static long F ( int N ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return 1 ; return F ( N - 1 ) + F ( N - 2 ); } public static void main ( String [] args ) { for ( int N = 0 ; N < 100 ; N ++ ) StdOut . println ( N + \" \" + F ( N )); } } What is the largest value of N for which this program takes less 1 hour to compute the value of F(N)? Develop a better implementation of F(N) that saves computed values in an array. On my machine any values more than 50 resulted in really slow computation. Here is a better version (using longs): public static long F ( long N ) { if ( N <= 1 ) { return N ; } long [] memo = new long [ ( int )( N + 1 ) ] ; memo [ 0 ] = 0 ; memo [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i += 1 ) { memo [ i ] = memo [ i - 1 ] + memo [ i - 2 ] ; } return memo [ ( int ) N ] ; } 1.1.20 \u00b6 Write a recursive static method that computes the value of ln (N !) Since $n! = 1 \u00d7 2 \u00d7 3 \u00d7 ... \u00d7 n$, then $ log(n!) = log(1) + log(2) + log(3) + \u2026 + log(n)$. Computing this for large values of n is costly. Since we are not asked for an approximation we can just calculate it directly. (using the lg function we implemented earlier) static int lnProduct ( int n ) { if ( n == 1 ) { return 0 ; } return lg ( n ) + lnProduct ( n - 1 ); } 1.1.21 \u00b6 Write a program that reads in lines from standard input with each line containing a name and two integers and then uses printf() to print a table with a column of the names, the integers, and the result of dividing the first by the second, accurate to three decimal places. You could use a program like this to tabulate batting averages for baseball players or grades for students. public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); while ( input . hasNextLine ()) { String line = input . nextLine (); String [] words = line . split ( \" \" ); String name = words [ 0 ] ; double first = Double . parseDouble ( words [ 1 ] ); double second = Double . parseDouble ( words [ 2 ] ); System . out . printf ( \"Name: %s, Div: %.3f\\n\" , name , first / second ); } } 1.1.22 \u00b6 Write a version of BinarySearch that uses the recursive rank() given on page 25 and traces the method calls. Each time the recursive method is called, print the argument values lo and hi, indented by the depth of the recursion. Hint: Add an argument to the recursive method that keeps track of the depth. public static int rank ( int key , int [] a ) { return rank ( key , a , 0 , a . length - 1 , 0 ); } public static String padLeft ( String inputString , int length ) { StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < length ; i ++ ) { sb . append ( ' ' ); } return sb . toString () + inputString ; } public static int rank ( int key , int [] a , int lo , int hi , int depth ) { String out = padLeft ( String . format ( \"lo: %d, hi: %d\\n\" , lo , hi ), depth ); System . out . print ( out ); if ( lo > hi ) return - 1 ; int mid = lo + ( hi - lo ) / 2 ; if ( key < a [ mid ] ) return rank ( key , a , lo , mid - 1 , depth + 1 ); else if ( key > a [ mid ] ) return rank ( key , a , mid + 1 , hi , depth + 1 ); else return mid ; } 1.1.23 Add to the BinarySearch test client the ability to respond to a second argument: + to print numbers from standard input that are not in the whitelist, - to print numbers that are in the whitelist. public static void main ( String [] args ) { int [] whitelist = readInts ( args [ 0 ] ); boolean printNotFromWhitelist = true ; if ( args [ 1 ] . equals ( \"+\" )) { printNotFromWhitelist = true ; } if ( args [ 1 ] . equals ( \"-\" )) { printNotFromWhitelist = false ; } Scanner scanner = new Scanner ( System . in ); Arrays . sort ( whitelist ); while ( scanner . hasNext ()) { // Read key, print if not in whitelist. int key = scanner . nextInt (); boolean notFound = rank ( key , whitelist ) < 0 ; // Print numbers from standard input that are not in the whitelist if ( notFound && printNotFromWhitelist ) { System . out . println ( key ); } // Print numbers from standard input that are in the whitelist if ( ! notFound && ! printNotFromWhitelist ) { System . out . println ( key ); } } } 1.1.24 \u00b6 Give the sequence of values of p and q that are computed when Euclid\u2019s algorithm is used to compute the greatest common divisor of 105 and 24. Extend the code given on page 4 to develop a program Euclid that takes two integers from the command line and computes their greatest common divisor, printing out the two arguments for each call on the recursive method. Use your program to compute the greatest common divisor or 1111111 and 1234567. Solution trivial... 1.1.25 \u00b6 Use mathematical induction to prove that Euclid\u2019s algorithm computes the greatest common divisor of any pair of nonnegative integers p and q. In GCD the process terminates when a remainder of 0 is reached, and the last nonzero remainder in the process is gcd(p, q) with $p \u2265 q$ The process in the Euclidean algorithm produces a strictly decreasing sequence of remainders $r0 > r1 > r2 > \u00b7 \u00b7 \u00b7 >rn+1 = 0$ Hence the algorithm stops after no more than q divisions. If $rn$ is the last non-zero remainder in the process, then we have $rn = gcd(rn, 0) = gcd(rn\u22121, rn) = ... = gcd(r0, r1) = gcd(p, q).$ For the base step $i = 0$, we have $gcd(p, q) = gcd(r0, r1)$ by definition of $r0 = a$ and $r1 = b$. For each i in 0 \u2264 i < n we have $gcd(ri, ri+1) = gcd(ri+1, ri+2)$ This shows that if $gcd(a, b) = gcd(ri, ri+1)$, then $gcd(a, b) = gcd(ri+1, ri+2),$ which is the induction step. 1.1.26 \u00b6 Sorting three numbers. Suppose that the variables a, b, c, and t are all of the same numeric primitive type. Show that the following code puts a, b, and c in ascending order: if ( a > b ) { t = a ; a = b ; b = t ; } if ( a > c ) { t = a ; a = c ; c = t ; } if ( b > c ) { t = b ; b = c ; c = t ; } The first if checks if $a > b$ and swaps $a$ with $b$. At the end we have $a < b$; The second if checks if $a > c$ and swaps $a$ with $c$. At the end we have $a < c$; The last if checks if $b > c$ and swaps $b$ with $c$. At the end we have $b < c$; From all three we have $a < b < c$. For example if $a=3, b=2, c=1$ we have: $3 > 2$ then $a = 2, b = 3$ $2 > 1$ then $a = 1, c = 2$ $3 > 2$ then $c = 3, b = 2$ 1.1.27 \u00b6 Binomial distribution. Estimate the number of recursive calls that would be used by the code: public static double binomial ( int N , int k , double p ) { if (( N == 0 ) || ( k < 0 )) return 1.0 ; return ( 1.0 - p ) * binomial ( N - 1 , k ) + p * binomial ( N - 1 , k - 1 ); } to compute binomial(100, 50). Develop a better implementation that is based on saving computed values in an array. Code seems to be wrong! We don't have a definition of binomial with two parameters! The code should have been: static int nChoseR ( int n , int r ) { // Since nCr is same as nC(n-r) // To decrease number of iterations if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ); answer /= i ; } return answer ; } static float binomialProbability ( int n , int k , float p ) { return nChoseR ( n , k ) * ( float ) Math . pow ( p , k ) * ( float ) Math . pow ( 1 - p , n - k ); } 1.1.28 \u00b6 Remove duplicates. Modify the test client in BinarySearch to remove any duplicate keys in the whitelist after the sort. When you find one of the indexes you're looking for, and from there, then check all the left and right indexes for the same value and remove them from the array public static void main ( String [] args ) { int [] whitelist = In . readInts ( args [ 0 ] ); Arrays . sort ( whitelist ); while ( ! StdIn . isEmpty ()) { // Read key, print if not in whitelist. int key = StdIn . readInt (); int index = rank ( key , whitelist ); // finds index of duplicate if ( index >= 0 ) { int start = index - 1 , end = index + 1 ; // Check left of index while ( start != 0 && whitelist [ start ] == key ) { if ( whitelist [ start ] == key ) { start -= 1 ; } else { break ; } } // Check right of index while ( end != whitelist . length - 1 ) { if ( whitelist [ end ] == key ) { end += 1 ; } else { break ; } } int numOfDuplicates = end - start ; if ( numOfDuplicates > 0 ) { // Copy first part int [] first = Arrays . copyOfRange ( whitelist , 0 , start ); // Copy second part int [] second = Arrays . copyOfRange ( whitelist , end + 1 , whitelist . length - 1 ); // Create result array with no duplicate keys int [] result = new int [ first . length + second . length + 1 ] ; System . arraycopy ( first , 0 , result , 0 , first . length ); // Assign key in position result [ first . length ] = key ; // Combine the results System . arraycopy ( second , 0 , result , first . length + 1 , second . length ); whitelist = result ; } } } } 1.1.29 \u00b6 Equal keys. Add to BinarySearch a static method rank() that takes a key and a sorted array of int values (some of which may be equal) as arguments and returns the number of elements that are smaller than the key and a similar method count() that returns the number of elements equal to the key. Note : If i and j are the values returned by rank(key, a) and count(key, a) respectively, then a[i..i+j-1] are the values in the array that are equal to key. /* Returns the number of elements that are smaller than the key */ static int rank ( int key , int [] a ) { int index = Arrays . binarySearch ( a , key ); int lessThanCount = 0 ; if ( index >= 0 ) { int curr = index - 1 ; while ( curr >= 0 ) { if ( a [ curr ] != key ) { lessThanCount += 1 ; } curr -= 1 ; } } return lessThanCount ; } /* Returns the number of elements equal to the key */ static int count ( int key , int [] a ) { int index = Arrays . binarySearch ( a , key ); int count = 0 ; if ( index >= 0 ) { count += 1 ; int start = index - 1 , end = index + 1 ; // Check left of index while ( start >= 0 ) { if ( a [ start ] == key ) { start -= 1 ; count += 1 ; } else { break ; } } // Check right of index while ( end < a . length - 1 ) { if ( a [ end ] == key ) { end += 1 ; count += 1 ; } else { break ; } } } return count ; }","title":"1.1   Programming Model"},{"location":"Chap01/1.1/#111","text":"Give the value of each of the following expressions: a. ( 0 + 15 ) / 2 b. 2.0e-6 * 100000000.1 c. true && false || true && true a. jshell> (0 + 15) / 2 $1 ==> 7 b. jshell> 2.0e-6 * 100000000.1 $2 ==> 200.0000002 c. jshell> true && false || true && true $3 ==> true","title":"1.1.1"},{"location":"Chap01/1.1/#112","text":"Give the type and value of each of the following expressions: a. (1 + 2.236)/2 b. 1 + 2 + 3 + 4.0 c. 4.1 >= 4 d. 1 + 2 + \"3\" a. jshell> (1 + 2.236)/2 $1 ==> 1.618 jshell> ((Object)1.618).getClass().getName() $2 ==> \"java.lang.Double\" b. jshell> 1 + 2 + 3 + 4.0 $3 ==> 10.0 // Double c. jshell> 4.1 >= 4 $4 ==> true // Boolean d. jshell> 1 + 2 + \"3\" $5 ==> \"33\"","title":"1.1.2"},{"location":"Chap01/1.1/#113","text":"Write a program that takes three integer command-line arguments and prints equal if all three are equal, and not equal otherwise. public static void main ( String [] args ) { int first = Integer . parseInt ( args [ 0 ] ); int second = Integer . parseInt ( args [ 1 ] ); int third = Integer . parseInt ( args [ 2 ] ); if ( first == second && second == third ) { System . out . println ( \"equal\" ); } else { System . out . println ( \"not equal\" ); } }","title":"1.1.3"},{"location":"Chap01/1.1/#114","text":"What (if anything) is wrong with each of the following statements? a. if (a > b) then c = 0; b. if a > b { c = 0; } c. if (a > b) c = 0; d. if (a > b) c = 0 else b = 0; a. The programs does not compile. | Error: | variable declaration not allowed here | if (a > b) then c = 0; | ^---------^ b. The program fails to compile. | Error: | '(' expected | if a > b { c = 0; } | ^ | Error: | ')' expected | if a > b { c = 0; } | ^ c. The problem compiles. d. The problem does not compile. It's missing a semicolon; jshell> if (a > b) c = 0 else b = 0; | Error: | ';' expected | if (a > b) c = 0 else b = 0; |","title":"1.1.4"},{"location":"Chap01/1.1/#115","text":"Write a code fragment that prints true if the double variables x and y are both strictly between 0 and 1 and false otherwise. static boolean areBetween0and1 ( double x , double y ) { return isBetween0and1 ( x ) && isBetween0and1 ( y ); } static boolean isBetween0and1 ( double x ) { if ( x > 0 && x < 1 ) { return true ; } return false ; }","title":"1.1.5"},{"location":"Chap01/1.1/#116","text":"What does the following program print? int f = 0 ; int g = 1 ; for ( int i = 0 ; i <= 15 ; i ++ ) { StdOut . println ( f ); f = f + g ; g = f - g ; } It prints: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610","title":"1.1.6"},{"location":"Chap01/1.1/#117","text":"Give the value printed by each of the following code fragments: a . double t = 9.0 ; while ( Math . abs ( t - 9.0 / t ) > .001 ) t = ( 9.0 / t + t ) / 2.0 ; StdOut . printf ( \"%.5f\\n\" , t ); b . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); c . int sum = 0 ; for ( int i = 1 ; i < 1000 ; i *= 2 ) for ( int j = 0 ; j < i ; j ++ ) sum ++ ; StdOut . println ( sum ); a) 3.00009 b) 499500 c) 1023","title":"1.1.7"},{"location":"Chap01/1.1/#118","text":"What do each of the following print? a. System.out.println('b'); b. System.out.println('b' + 'c'); c. System.out.println((char) ('a' + 4)); Explain each outcome. a) It prints 'b' and a new line b) It prints 197. First 'b' is converted to int (98) and then 'c' to int (99) so the total is 98 + 99 = 197 c) It prints 'e'. First ('a' + 4) is converted to int. 'a' is 97 so result is 97 + 4 = 101. Then this int is converted to char which is 'e';","title":"1.1.8"},{"location":"Chap01/1.1/#1111","text":"Write a code fragment that prints the contents of a two-dimensional boolean array, using * to represent true and a space to represent false. Include row and column numbers. static void printContents ( boolean [][] arr ) { for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { if ( arr [ i ][ j ] ) { System . out . printf ( \"row: %d, column: %d = *\\n\" , i , j ); } else { System . out . printf ( \"row: %d, column: %d = \\n\" , i , j ); } } } }","title":"1.1.11"},{"location":"Chap01/1.1/#1112","text":"What does the following code fragment print? int [] a = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = 9 - i ; for ( int i = 0 ; i < 10 ; i ++ ) a [ i ] = a [ a [ i ]] ; for ( int i = 0 ; i < 10 ; i ++ ) System . out . println ( i ); It prints: 0 1 2 3 4 5 6 7 8 9","title":"1.1.12"},{"location":"Chap01/1.1/#1113","text":"Write a code fragment to print the transposition (rows and columns changed) of a two-dimensional array with M rows and N columns. static void printTranspose ( int [][] arr ) { int [][] result = new int [ arr [ 0 ] . length ][ arr . length ] ; for ( int i = 0 ; i < arr . length ; i += 1 ) { for ( int j = 0 ; j < arr [ i ] . length ; j += 1 ) { result [ j ][ i ] = arr [ i ][ j ] ; } } for ( int i = 0 ; i < result . length ; i += 1 ) { for ( int j = 0 ; j < result [ i ] . length ; j += 1 ) { System . out . printf ( \"row: %d, column: %d = %d\\n\" , i , j , result [ i ][ j ] ); } } }","title":"1.1.13"},{"location":"Chap01/1.1/#1114","text":"Write a static method lg() that takes an int value N as argument and returns the largest int not larger than the base-2 logarithm of N. Do not use Math. static int lg ( int n ) { if ( n == 1 ) { return 0 ; } if ( n == 2 ) { return 1 ; } int acc = 2 ; int result = 1 ; while ( acc * 2 <= n ) { acc *= 2 ; result += 1 ; } return result ; }","title":"1.1.14"},{"location":"Chap01/1.1/#1115","text":"Write a static method histogram() that takes an array a[] of int values and an integer M as arguments and returns an array of length M whose ith entry is the number of times the integer i appeared in the argument array. If the values in a[] are all between 0 and M\u20131, the sum of the values in the returned array should be equal to a.length. static int [] histogram ( int [] arr , int M ) { int [] result = new int [ M ] ; for ( int i : arr ) { if ( i < M ) { result [ i ] += 1 ; } } return result ; }","title":"1.1.15"},{"location":"Chap01/1.1/#1116","text":"Give the value of exR1(6): public static String exR1 ( int n ) { if ( n <= 0 ) return \"\" ; return exR1 ( n - 3 ) + n + exR1 ( n - 2 ) + n ; } Result is 311361142246","title":"1.1.16"},{"location":"Chap01/1.1/#1118","text":"Consider the following recursive function: public static int mystery ( int a , int b ) { if ( b == 0 ) return 0 ; if ( b % 2 == 0 ) return mystery ( a + a , b / 2 ); return mystery ( a + a , b / 2 ) + a ; } What are the values of mystery(2, 25) and mystery(3, 11)? Given positive integers a and b, describe what value mystery(a, b) computes. Answer the same question, but replace + with * and replace return 0 with return 1. mystery(2, 25) prints 2 * 25 = 50 mystery(3, 11) prints 3 * 11 = 33 mystery indeed computes $a * b$; If we replace + with * and 0 with 1 the fuction becomes: public static int mystery ( int a , int b ) { if ( b == 0 ) return 1 ; if ( b % 2 == 0 ) return mystery ( a * a , b / 2 ); return mystery ( a * a , b / 2 ) * a ; } This computes the value $a^b$.","title":"1.1.18"},{"location":"Chap01/1.1/#1119","text":"Run the following program on your computer: public class Fibonacci { public static long F ( int N ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return 1 ; return F ( N - 1 ) + F ( N - 2 ); } public static void main ( String [] args ) { for ( int N = 0 ; N < 100 ; N ++ ) StdOut . println ( N + \" \" + F ( N )); } } What is the largest value of N for which this program takes less 1 hour to compute the value of F(N)? Develop a better implementation of F(N) that saves computed values in an array. On my machine any values more than 50 resulted in really slow computation. Here is a better version (using longs): public static long F ( long N ) { if ( N <= 1 ) { return N ; } long [] memo = new long [ ( int )( N + 1 ) ] ; memo [ 0 ] = 0 ; memo [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i += 1 ) { memo [ i ] = memo [ i - 1 ] + memo [ i - 2 ] ; } return memo [ ( int ) N ] ; }","title":"1.1.19"},{"location":"Chap01/1.1/#1120","text":"Write a recursive static method that computes the value of ln (N !) Since $n! = 1 \u00d7 2 \u00d7 3 \u00d7 ... \u00d7 n$, then $ log(n!) = log(1) + log(2) + log(3) + \u2026 + log(n)$. Computing this for large values of n is costly. Since we are not asked for an approximation we can just calculate it directly. (using the lg function we implemented earlier) static int lnProduct ( int n ) { if ( n == 1 ) { return 0 ; } return lg ( n ) + lnProduct ( n - 1 ); }","title":"1.1.20"},{"location":"Chap01/1.1/#1121","text":"Write a program that reads in lines from standard input with each line containing a name and two integers and then uses printf() to print a table with a column of the names, the integers, and the result of dividing the first by the second, accurate to three decimal places. You could use a program like this to tabulate batting averages for baseball players or grades for students. public static void main ( String [] args ) { Scanner input = new Scanner ( System . in ); while ( input . hasNextLine ()) { String line = input . nextLine (); String [] words = line . split ( \" \" ); String name = words [ 0 ] ; double first = Double . parseDouble ( words [ 1 ] ); double second = Double . parseDouble ( words [ 2 ] ); System . out . printf ( \"Name: %s, Div: %.3f\\n\" , name , first / second ); } }","title":"1.1.21"},{"location":"Chap01/1.1/#1122","text":"Write a version of BinarySearch that uses the recursive rank() given on page 25 and traces the method calls. Each time the recursive method is called, print the argument values lo and hi, indented by the depth of the recursion. Hint: Add an argument to the recursive method that keeps track of the depth. public static int rank ( int key , int [] a ) { return rank ( key , a , 0 , a . length - 1 , 0 ); } public static String padLeft ( String inputString , int length ) { StringBuilder sb = new StringBuilder (); for ( int i = 0 ; i < length ; i ++ ) { sb . append ( ' ' ); } return sb . toString () + inputString ; } public static int rank ( int key , int [] a , int lo , int hi , int depth ) { String out = padLeft ( String . format ( \"lo: %d, hi: %d\\n\" , lo , hi ), depth ); System . out . print ( out ); if ( lo > hi ) return - 1 ; int mid = lo + ( hi - lo ) / 2 ; if ( key < a [ mid ] ) return rank ( key , a , lo , mid - 1 , depth + 1 ); else if ( key > a [ mid ] ) return rank ( key , a , mid + 1 , hi , depth + 1 ); else return mid ; } 1.1.23 Add to the BinarySearch test client the ability to respond to a second argument: + to print numbers from standard input that are not in the whitelist, - to print numbers that are in the whitelist. public static void main ( String [] args ) { int [] whitelist = readInts ( args [ 0 ] ); boolean printNotFromWhitelist = true ; if ( args [ 1 ] . equals ( \"+\" )) { printNotFromWhitelist = true ; } if ( args [ 1 ] . equals ( \"-\" )) { printNotFromWhitelist = false ; } Scanner scanner = new Scanner ( System . in ); Arrays . sort ( whitelist ); while ( scanner . hasNext ()) { // Read key, print if not in whitelist. int key = scanner . nextInt (); boolean notFound = rank ( key , whitelist ) < 0 ; // Print numbers from standard input that are not in the whitelist if ( notFound && printNotFromWhitelist ) { System . out . println ( key ); } // Print numbers from standard input that are in the whitelist if ( ! notFound && ! printNotFromWhitelist ) { System . out . println ( key ); } } }","title":"1.1.22"},{"location":"Chap01/1.1/#1124","text":"Give the sequence of values of p and q that are computed when Euclid\u2019s algorithm is used to compute the greatest common divisor of 105 and 24. Extend the code given on page 4 to develop a program Euclid that takes two integers from the command line and computes their greatest common divisor, printing out the two arguments for each call on the recursive method. Use your program to compute the greatest common divisor or 1111111 and 1234567. Solution trivial...","title":"1.1.24"},{"location":"Chap01/1.1/#1125","text":"Use mathematical induction to prove that Euclid\u2019s algorithm computes the greatest common divisor of any pair of nonnegative integers p and q. In GCD the process terminates when a remainder of 0 is reached, and the last nonzero remainder in the process is gcd(p, q) with $p \u2265 q$ The process in the Euclidean algorithm produces a strictly decreasing sequence of remainders $r0 > r1 > r2 > \u00b7 \u00b7 \u00b7 >rn+1 = 0$ Hence the algorithm stops after no more than q divisions. If $rn$ is the last non-zero remainder in the process, then we have $rn = gcd(rn, 0) = gcd(rn\u22121, rn) = ... = gcd(r0, r1) = gcd(p, q).$ For the base step $i = 0$, we have $gcd(p, q) = gcd(r0, r1)$ by definition of $r0 = a$ and $r1 = b$. For each i in 0 \u2264 i < n we have $gcd(ri, ri+1) = gcd(ri+1, ri+2)$ This shows that if $gcd(a, b) = gcd(ri, ri+1)$, then $gcd(a, b) = gcd(ri+1, ri+2),$ which is the induction step.","title":"1.1.25"},{"location":"Chap01/1.1/#1126","text":"Sorting three numbers. Suppose that the variables a, b, c, and t are all of the same numeric primitive type. Show that the following code puts a, b, and c in ascending order: if ( a > b ) { t = a ; a = b ; b = t ; } if ( a > c ) { t = a ; a = c ; c = t ; } if ( b > c ) { t = b ; b = c ; c = t ; } The first if checks if $a > b$ and swaps $a$ with $b$. At the end we have $a < b$; The second if checks if $a > c$ and swaps $a$ with $c$. At the end we have $a < c$; The last if checks if $b > c$ and swaps $b$ with $c$. At the end we have $b < c$; From all three we have $a < b < c$. For example if $a=3, b=2, c=1$ we have: $3 > 2$ then $a = 2, b = 3$ $2 > 1$ then $a = 1, c = 2$ $3 > 2$ then $c = 3, b = 2$","title":"1.1.26"},{"location":"Chap01/1.1/#1127","text":"Binomial distribution. Estimate the number of recursive calls that would be used by the code: public static double binomial ( int N , int k , double p ) { if (( N == 0 ) || ( k < 0 )) return 1.0 ; return ( 1.0 - p ) * binomial ( N - 1 , k ) + p * binomial ( N - 1 , k - 1 ); } to compute binomial(100, 50). Develop a better implementation that is based on saving computed values in an array. Code seems to be wrong! We don't have a definition of binomial with two parameters! The code should have been: static int nChoseR ( int n , int r ) { // Since nCr is same as nC(n-r) // To decrease number of iterations if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ); answer /= i ; } return answer ; } static float binomialProbability ( int n , int k , float p ) { return nChoseR ( n , k ) * ( float ) Math . pow ( p , k ) * ( float ) Math . pow ( 1 - p , n - k ); }","title":"1.1.27"},{"location":"Chap01/1.1/#1128","text":"Remove duplicates. Modify the test client in BinarySearch to remove any duplicate keys in the whitelist after the sort. When you find one of the indexes you're looking for, and from there, then check all the left and right indexes for the same value and remove them from the array public static void main ( String [] args ) { int [] whitelist = In . readInts ( args [ 0 ] ); Arrays . sort ( whitelist ); while ( ! StdIn . isEmpty ()) { // Read key, print if not in whitelist. int key = StdIn . readInt (); int index = rank ( key , whitelist ); // finds index of duplicate if ( index >= 0 ) { int start = index - 1 , end = index + 1 ; // Check left of index while ( start != 0 && whitelist [ start ] == key ) { if ( whitelist [ start ] == key ) { start -= 1 ; } else { break ; } } // Check right of index while ( end != whitelist . length - 1 ) { if ( whitelist [ end ] == key ) { end += 1 ; } else { break ; } } int numOfDuplicates = end - start ; if ( numOfDuplicates > 0 ) { // Copy first part int [] first = Arrays . copyOfRange ( whitelist , 0 , start ); // Copy second part int [] second = Arrays . copyOfRange ( whitelist , end + 1 , whitelist . length - 1 ); // Create result array with no duplicate keys int [] result = new int [ first . length + second . length + 1 ] ; System . arraycopy ( first , 0 , result , 0 , first . length ); // Assign key in position result [ first . length ] = key ; // Combine the results System . arraycopy ( second , 0 , result , first . length + 1 , second . length ); whitelist = result ; } } } }","title":"1.1.28"},{"location":"Chap01/1.1/#1129","text":"Equal keys. Add to BinarySearch a static method rank() that takes a key and a sorted array of int values (some of which may be equal) as arguments and returns the number of elements that are smaller than the key and a similar method count() that returns the number of elements equal to the key. Note : If i and j are the values returned by rank(key, a) and count(key, a) respectively, then a[i..i+j-1] are the values in the array that are equal to key. /* Returns the number of elements that are smaller than the key */ static int rank ( int key , int [] a ) { int index = Arrays . binarySearch ( a , key ); int lessThanCount = 0 ; if ( index >= 0 ) { int curr = index - 1 ; while ( curr >= 0 ) { if ( a [ curr ] != key ) { lessThanCount += 1 ; } curr -= 1 ; } } return lessThanCount ; } /* Returns the number of elements equal to the key */ static int count ( int key , int [] a ) { int index = Arrays . binarySearch ( a , key ); int count = 0 ; if ( index >= 0 ) { count += 1 ; int start = index - 1 , end = index + 1 ; // Check left of index while ( start >= 0 ) { if ( a [ start ] == key ) { start -= 1 ; count += 1 ; } else { break ; } } // Check right of index while ( end < a . length - 1 ) { if ( a [ end ] == key ) { end += 1 ; count += 1 ; } else { break ; } } } return count ; }","title":"1.1.29"},{"location":"Chap01/1.2/","text":"","title":"1.2   Data Abstraction"},{"location":"Chap01/1.3/","text":"","title":"1.3   Bags, Queues, and Stacks"},{"location":"Chap01/1.4/","text":"","title":"1.4   Analysis of Algorithms"},{"location":"Chap01/1.5/","text":"","title":"1.5   Case Study - Union-Find"}]}