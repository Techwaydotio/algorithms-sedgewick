## 1.2.1 
> Write a Point2D client that takes an integer value N from the command line,
generates N random points in the unit square, and computes the distance separating
the closest pair of points.

Brute force approach:

```java
public class Ex121 {
    int N;

    public static void main(String[] args) {
        int N = Integer.parseInt(args[0]);
        Point2D.Double[] points = new Point2D.Double[N];
        for (int i = 0; i < N; i += 1) {
            double x = ThreadLocalRandom.current().nextDouble(0, 400);
            double y = ThreadLocalRandom.current().nextDouble(0, 400);
            points[i] = new Point2D.Double(x, y);
        }

        System.out.println(findClosestPairsBruteForce(points));
    }

    static double dist(Point2D p1, Point2D p2) {
        return Math.sqrt((p1.getX() - p2.getY()) * (p1.getX() - p2.getX()) +
                (p1.getY() - p2.getY()) * (p1.getY() - p2.getY())
        );
    }

    static double findClosestPairsBruteForce(Point2D[] points) {
        double min = Double.MAX_VALUE;
        for (int i = 0; i < points.length; i += 1)
            for (int j = i + 1; j < points.length; j += 1)
                if (dist(points[i], points[j]) < min)
                    min = dist(points[i], points[j]);
        return min;
    }
}
```

## 1.2.2 
> Write an Interval1D client that takes an int value N as command-line argument, reads N intervals (each defined by a pair of double values) from standard input,
and prints all pairs that intersect.

**TODO**

## 1.2.3 

>> Write an Interval2D client that takes command-line arguments N, min, and max
and generates N random 2D intervals whose width and height are uniformly distributed
between min and max in the unit square. Draw them on StdDraw and print the number
of pairs of intervals that intersect and the number of intervals that are contained in one
another.

**TODO**

## 1.2.6 
> A string s is a circular rotation of a string t if it matches when the characters
are circularly shifted by any number of positions; e.g., ACTGACG is a circular shift of
TGACGAC, and vice versa. Detecting this condition is important in the study of genomic
sequences. Write a program that checks whether two given strings s and t are circular
shifts of one another. Hint : The solution is a one-liner with indexOf(), length(), and
string concatenation.

Solution is based from [this article](https://javarevisited.blogspot.com/2017/07/2-ways-to-check-if-one-string-is-rotation-of-another-String.html
):


```java
static boolean isCircular(String a, String b) {
    boolean result = false;
    if (a == null || b == null) {
        return false;
    }
    if (a.length() != b.length()) {
        return false;
    }
    String combined = a + a;
    if (combined.indexOf(b) >= 0) {
        result = true;
    }
    return result;
}
```

## 1.2.7 
> What does the following recursive function return?

```java
public static String mystery(String s){
 int N = s.length();
 if (N <= 1) return s;
 String a = s.substring(0, N/2);
 String b = s.substring(N/2, N);
 return mystery(b) + mystery(a);
}
```

It reverses the provided string. For example `ABCDEFG` becomes `GFEDCBA`.
